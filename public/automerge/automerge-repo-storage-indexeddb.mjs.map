{"mappings":"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","names":["IndexedDBStorageAdapter","database","store","resolve","reject","request","event","db","keyArray","transaction","result","binary","keyPrefix","lowerBound","upperBound","range","cursor"],"sourceRoot":"/","sources":["../esmd/npm/@automerge/automerge-repo-storage-indexeddb@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo-storage-indexeddb@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo-storage-indexeddb/dist/index.js"],"sourcesContent":["/**\n * This module provides a storage adapter for IndexedDB.\n *\n * @packageDocumentation\n */\nexport class IndexedDBStorageAdapter {\n    database;\n    store;\n    dbPromise;\n    /** Create a new {@link IndexedDBStorageAdapter}.\n     * @param database - The name of the database to use. Defaults to \"automerge\".\n     * @param store - The name of the object store to use. Defaults to \"documents\".\n     */\n    constructor(database = \"automerge\", store = \"documents\") {\n        this.database = database;\n        this.store = store;\n        this.dbPromise = this.createDatabasePromise();\n    }\n    createDatabasePromise() {\n        return new Promise((resolve, reject) =\u003e {\n            const request = indexedDB.open(this.database, 1);\n            request.onerror = () =\u003e {\n                reject(request.error);\n            };\n            request.onupgradeneeded = event =\u003e {\n                const db = event.target.result;\n                db.createObjectStore(this.store);\n            };\n            request.onsuccess = event =\u003e {\n                const db = event.target.result;\n                resolve(db);\n            };\n        });\n    }\n    async load(keyArray) {\n        const db = await this.dbPromise;\n        const transaction = db.transaction(this.store);\n        const objectStore = transaction.objectStore(this.store);\n        const request = objectStore.get(keyArray);\n        return new Promise((resolve, reject) =\u003e {\n            transaction.onerror = () =\u003e {\n                reject(request.error);\n            };\n            request.onsuccess = event =\u003e {\n                const result = event.target.result;\n                if (result \u0026\u0026 typeof result === \"object\" \u0026\u0026 \"binary\" in result) {\n                    resolve(result.binary);\n                }\n                else {\n                    resolve(undefined);\n                }\n            };\n        });\n    }\n    async save(keyArray, binary) {\n        const db = await this.dbPromise;\n        const transaction = db.transaction(this.store, \"readwrite\");\n        const objectStore = transaction.objectStore(this.store);\n        objectStore.put({ key: keyArray, binary: binary }, keyArray);\n        return new Promise((resolve, reject) =\u003e {\n            transaction.onerror = () =\u003e {\n                reject(transaction.error);\n            };\n            transaction.oncomplete = () =\u003e {\n                resolve();\n            };\n        });\n    }\n    async remove(keyArray) {\n        const db = await this.dbPromise;\n        const transaction = db.transaction(this.store, \"readwrite\");\n        const objectStore = transaction.objectStore(this.store);\n        objectStore.delete(keyArray);\n        return new Promise((resolve, reject) =\u003e {\n            transaction.onerror = () =\u003e {\n                reject(transaction.error);\n            };\n            transaction.oncomplete = () =\u003e {\n                resolve();\n            };\n        });\n    }\n    async loadRange(keyPrefix) {\n        const db = await this.dbPromise;\n        const lowerBound = keyPrefix;\n        const upperBound = [...keyPrefix, \"\\uffff\"];\n        const range = IDBKeyRange.bound(lowerBound, upperBound);\n        const transaction = db.transaction(this.store);\n        const objectStore = transaction.objectStore(this.store);\n        const request = objectStore.openCursor(range);\n        const result = [];\n        return new Promise((resolve, reject) =\u003e {\n            transaction.onerror = () =\u003e {\n                reject(request.error);\n            };\n            request.onsuccess = event =\u003e {\n                const cursor = event.target.result;\n                if (cursor) {\n                    result.push({\n                        data: cursor.value.binary,\n                        key: cursor.key,\n                    });\n                    cursor.continue();\n                }\n                else {\n                    resolve(result);\n                }\n            };\n        });\n    }\n    async removeRange(keyPrefix) {\n        const db = await this.dbPromise;\n        const lowerBound = keyPrefix;\n        const upperBound = [...keyPrefix, \"\\uffff\"];\n        const range = IDBKeyRange.bound(lowerBound, upperBound);\n        const transaction = db.transaction(this.store, \"readwrite\");\n        const objectStore = transaction.objectStore(this.store);\n        objectStore.delete(range);\n        return new Promise((resolve, reject) =\u003e {\n            transaction.onerror = () =\u003e {\n                reject(transaction.error);\n            };\n            transaction.oncomplete = () =\u003e {\n                resolve();\n            };\n        });\n    }\n}\n"],"version":3}

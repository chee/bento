{"mappings":"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","names":["require_ms","__commonJSMin","exports","module","s","m","h","d","w","y","val","options","type","parse","fmtLong","fmtShort","str","match","n","ms","msAbs","plural","name","isPlural","require_common","__commonJSMin","exports","module","setup","env","createDebug","coerce","disable","enable","enabled","destroy","key","selectColor","namespace","hash","i","prevTime","enableOverride","namespacesCache","enabledCache","debug","args","self","curr","ms","index","match","format","formatter","val","extend","v","delimiter","newDebug","namespaces","split","len","toNamespace","name","regexp","require_browser","__commonJSMin","exports","module","formatArgs","save","load","useColors","localstorage","warned","m","args","c","index","lastC","match","namespaces","r","formatters","v","error","require_eventemitter3","__commonJSMin","exports","module","has","prefix","Events","EE","fn","context","once","addListener","emitter","event","listener","evt","clearEvent","EventEmitter","names","events","name","handlers","i","l","ee","listeners","a1","a2","a3","a4","a5","len","args","length","j","exports","isBytes","number","bool","bytes","hash","exists","output","n","b","a","lengths","h","instance","checkFinished","out","min","assert","exports","exports","isBytes","byteSwap32","bytesToHex","hexToBytes","asyncLoop","utf8ToBytes","toBytes","concatBytes","checkOpts","wrapConstructor","wrapConstructorWithOpts","wrapXOFConstructorWithOpts","randomBytes","crypto_1","_assert_js_1","a","u8","arr","u32","createView","rotr","word","shift","rotl","byteSwap","n","i","hexes","_","bytes","hex","asciis","asciiToBase16","char","hl","al","array","ai","hi","n1","n2","nextTick","iters","tick","cb","ts","diff","str","data","arrays","sum","res","pad","Hash","toStr","defaults","opts","hashCons","hashC","msg","tmp","bytesLength","_assert_js_1","utils_js_1","setBigUint64","view","byteOffset","value","isLE","_32n","_u32_max","wh","wl","h","l","Chi","a","b","c","exports","Maj","HashMD","blockLen","outputLen","padOffset","data","buffer","len","pos","take","dataView","out","i","oview","outLen","state","res","to","length","finished","destroyed","_md_js_1","utils_js_1","SHA256_K","SHA256_IV","SHA256_W","SHA256","A","B","C","D","E","F","G","H","view","offset","i","W15","W2","s0","s1","sigma1","T1","T2","exports","SHA224","require_src","__commonJSMin","exports","module","base","ALPHABET","BASE_MAP","j","i","x","xc","BASE","LEADER","FACTOR","iFACTOR","encode","source","zeroes","length","pbegin","pend","size","b58","carry","it1","it2","str","decodeUnsafe","psz","b256","it3","it4","vch","decode","string","buffer","require_bs58","__commonJSMin","exports","module","basex","ALPHABET","require_base","__commonJSMin","exports","module","base58","checksumFn","encode","payload","payloadU8","checksum","length","both","decodeRaw","buffer","newChecksum","decodeUnsafe","string","decode","require_bs58check","__commonJSMin","exports","module","sha256","bs58checkBase","sha256x2","buffer","require_sha256","__commonJSMin","exports","module","root","factory","sha256","k","K","hashBlocks","w","v","pos","len","a","b","c","d","e","f","g","h","u","i","j","t1","t2","Hash","data","dataLength","dataPos","out","bytesHashed","left","bitLenHi","bitLenLo","padLength","from","HMAC","key","pad","hash","digest","hmac","fillBuffer","buffer","info","counter","num","hkdfSalt","hkdf","salt","length","okm","hmac_","bufpos","pbkdf2","password","iterations","dkLen","prf","ctr","t","dk","STATE","TRACE","OBJECT_ID","IS_PROXY","CLEAR_CACHE","UINT","INT","F64","COUNTER","TEXT","Text","_Text","text","TEXT","index","elems","elem","chars","value","STATE","values","v","numDelete","callback","searchElement","fromIndex","other","test","f","sep","start","end","Counter","value","COUNTER","_delta","WriteableCounter","context","path","objectId","key","delta","getWriteableCounter","RawString","val","parseListIndex","key","valueAt","target","prop","context","objectId","path","textV2","value","datatype","val","mapProxy","listProxy","textProxy","getWriteableCounter","import_value","type","UINT","INT","F64","COUNTER","RawString","Text","isSameDocument","printPath","_b","_c","STATE","MapHandler","cache","OBJECT_ID","IS_PROXY","TRACE","CLEAR_CACHE","list","proxyList","i","assertString","assertText","text","map","proxyMap","keys","ListHandler","index","instance","listMethods","elem","TextHandler","textMethods","proxied","listMethods","target","context","objectId","path","textV2","index","numDelete","val","start","end","value","datatype","import_value","length","parseListIndex","i","assertString","assertText","text","proxyText","textProxy","OBJECT_ID","values","last","valueAt","len","first","del","vals","isSameDocument","result","e","list","listProxy","map","proxyMap","mapProxy","key","f","other","v","elem","sep","initialValue","search","fromIndex","num","textMethods","spans","chars","o","Text","printPath","jsonPointerComponents","component","getRandomValues","rnds8","rng","byteToHex","i","unsafeStringify","arr","offset","randomUUID","native_default","v4","options","buf","offset","native_default","rnds","rng","i","unsafeStringify","v4_default","defaultFactory","v4_default","factory","uuid","newFactory","wasm","heap","heap_next","heap","cachedTextEncoder","encodeString","arg","view","buf","cachedTextDecoder","TextRepresentation","AutomergeFinalization","ptr","wasm","SyncStateFinalization","ptr","wasm","SyncStateSymbol","import_debug","import_index","import_bs58check","cbor_exports","__export","decode","encode","decoder","src","srcEnd","position","EMPTY_ARRAY","LEGACY_RECORD_INLINE_ID","RECORD_DEFINITIONS_ID","RECORD_INLINE_ID","BUNDLED_STRINGS_ID","PACKED_REFERENCE_TAG_ID","STOP_CODE","maxArraySize","maxMapSize","strings","EMPTY_ARRAY","stringPosition","currentDecoder","currentStructures","srcString","srcStringStart","srcStringEnd","bundledStrings","referenceMap","currentExtensions","currentExtensionRanges","packedValues","dataView","restoreMapsAsObject","defaultOptions","sequentialMode","inlineObjectReadThreshold","inlineObjectReadThreshold","Decoder","_Decoder","options","k","v","key","rec","map","res","safeKey","source","end","r","src","saveState","clearSource","defaultOptions","srcEnd","position","stringPosition","srcStringEnd","srcString","strings","EMPTY_ARRAY","bundledStrings","dataView","error","currentDecoder","packedValues","currentStructures","checkedRead","forEach","values","lastPosition","size","sequentialMode","value","defaultDecoder","checkedRead","result","read","bundledStrings","position","error","srcEnd","currentStructures","src","referenceMap","sequentialMode","clearSource","token","majorType","getFloat16","dataView","value","currentDecoder","multiplier","mult10","array","i","STOP_CODE","maxArraySize","key","object","maxMapSize","safeKey","restoreMapsAsObject","map","readBin","srcStringEnd","srcString","srcStringStart","string","shortStringInJS","longStringInJS","readFixedString","BUNDLED_STRINGS_ID","structure","createStructureReader","RECORD_INLINE_ID","length","readJustLength","id","recordDefinition","RECORD_DEFINITIONS_ID","readBundleExt","loadShared","extension","currentExtensions","input","currentExtensionRanges","Tag","packedValue","packedValues","getPackedValues","validName","readObject","compiledReader","inlineObjectReadThreshold","k","readStringJS","readStringJS","length","result","shortStringInJS","decoder","src","position","end","units","byte1","byte2","byte3","byte4","unit","fromCharCode","longStringInJS","start","bytes","i","byte","a","b","c","d","e","f","g","h","j","k","l","m","n","o","readBin","currentDecoder","f32Array","u8Array","getFloat16","byte0","src","position","byte1","exponent","abs","keyCache","Tag","value","tag","currentExtensions","dateString","epochSec","buffer","i","l","fraction","recordDefinition","id","structure","existingStructure","currentStructures","createStructureReader","LEGACY_RECORD_INLINE_ID","data","length","object","key","safeKey","bundledStrings","glbl","packedTable","read","src","position","error","newPackedValues","packedValues","PACKED_REFERENCE_TAG_ID","currentDecoder","loadShared","referenceMap","startingPosition","token","target","refEntry","targetProperties","array","restoreMapsAsObject","combine","a","b","getPackedValues","SHARED_DATA_TAG_ID","currentExtensionRanges","input","isLittleEndianMachine","typedArrays","typedArrayTags","registerTypedArray","TypedArray","dvMethod","bytesPerElement","littleEndian","sizeShift","dv","elements","ta","method","readBundleExt","readJustLength","bundlePosition","bundleLength","dataPosition","readStringJS","dataView","sharedData","saveState","updatedStructures","callback","savedSrcEnd","srcEnd","savedPosition","savedStringPosition","stringPosition","savedSrcStringStart","srcStringStart","savedSrcStringEnd","srcStringEnd","savedSrcString","srcString","savedStrings","strings","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedDecoder","savedSequentialMode","sequentialMode","clearSource","mult10","i","defaultDecoder","Decoder","decode","decodeMultiple","FLOAT32_OPTIONS","textEncoder","extensions","extensionClasses","Buffer","hasNodeBuffer","ByteArrayAllocate","ByteArray","MAX_STRUCTURES","MAX_BUFFER_SIZE","throwOnIterable","target","targetView","position","safeEnd","bundledStrings","MAX_BUNDLE_SIZE","hasNonLatin","RECORD_SYMBOL","Encoder","Decoder","options","typeBuffer","start","sharedStructures","hasSharedUpdate","structures","referenceMap","encodeUtf8","ByteArray","string","maxBytes","textEncoder","encoder","hasSharedStructures","maxSharedStructures","isSequential","samplingPackedValues","packedObjectMap","sharedValues","sharedPackedObjectMap","i","l","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","value","encodeOptions","r","ByteArrayAllocate","REUSE_BUFFER_MODE","sharedData","sharedStructuresLength","keys","nextTransition","transition","j","key","packedValues","findRepetitiveStrings","writeArrayHeader","valuesArray","encode","THROW_ON_ITERABLE","writeBundles","makeRoom","serialized","insertIds","returnBuffer","RESET_BUFFER_MODE","threshold","status","type","length","packedPosition","strLength","extStart","twoByte","headerSize","c1","c2","strPosition","useFloat32","xShifted","mult10","referee","idsToInsert","constructor","writeObject","entryValue","extensions","extensionClass","extensionClasses","extension","tag","error","entry","isBlob","json","bytes","writeBuffer","object","vals","objectOffset","size","skipValues","newTransitions","parentRecordId","k","recordId","MAX_STRUCTURES","end","newSize","MAX_BUFFER_SIZE","newBuffer","chunkThreshold","continuedChunkThreshold","startEncoding","encodeObjectAsIterable","encodeObjectAsAsyncIterable","iterateProperties","finalIterable","useRecords","writeEntityLength","tryEncode","restartEncoding","restart","encodeIterable","encodedValue","reader","next","asyncValue","buffer","lastVersion","structuresCopy","SharedData","saveResults","existingShared","structure","majorValue","values","version","BlobConstructor","packedStatus","includeKeys","isLittleEndianMachine","Tag","date","seconds","set","array","regex","arrayBuffer","typedArray","hasNodeBuffer","typedArrayEncoder","definitions","offset","Buffer","nextId","distanceToMove","lastEnd","a","b","id","writeStrings","defaultEncoder","Encoder","encode","encodeAsIterable","encodeAsAsyncIterable","NEVER","ALWAYS","DECIMAL_ROUND","DECIMAL_FIT","FLOAT32_OPTIONS","REUSE_BUFFER_MODE","RESET_BUFFER_MODE","THROW_ON_ITERABLE","encode","obj","Encoder","decode","buf","HandleState","IDLE","LOADING","REQUESTING","READY","DELETED","UNAVAILABLE","import_debug","import_debug","import_debug","import_debug","sha256","import_debug","import_debug","log","debug","NetworkAdapter","EventEmitter","ws","browser_default","import_debug","isJoinMessage","message","isPeerMessage","isErrorMessage","ProtocolV1","assert","value","message","error","trimLines","removeLine","s","targetText","line","toArrayBuffer","bytes","buffer","byteOffset","byteLength","WebSocketNetworkAdapter","NetworkAdapter","BrowserWebSocketClientAdapter","#ready","#readyResolver","#readyPromise","resolve","#forceReady","#retryIntervalId","#log","debug","url","retryInterval","peerId","peerMetadata","assert","browser_default","event","joinMessage","socket","message","encoded","cbor_exports","toArrayBuffer","remotePeerId","messageBytes","isPeerMessage","isErrorMessage","senderId","ProtocolV1","import_debug","log","debug","encode","decode","cbor_exports","NodeWSServerAdapter","NetworkAdapter","#ready","#readyResolver","#readyPromise","resolve","#forceReady","server","keepAliveInterval","peerId","peerMetadata","keepAliveId","socket","#removeSocket","message","#terminate","assert","senderId","encoded","arrayBuf","toArrayBuffer","messageBytes","type","myPeerId","documentId","byteLength","isJoinMessage","supportedProtocolVersions","existingSocket","browser_default","selectProtocol","ProtocolV1","#peerIdBySocket","isThisSocket","versions"],"sourceRoot":"/","sources":["../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/browser.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/src/_assert.ts","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/src/crypto.ts","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/src/utils.ts","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/src/_md.ts","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@noble+hashes@1.5.0/node_modules/@noble/hashes/src/sha256.ts","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/base-x@4.0.0/node_modules/base-x/src/index.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/bs58@5.0.0/node_modules/bs58/index.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/bs58check@3.0.1/node_modules/bs58check/base.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/bs58check@3.0.1/node_modules/bs58check/index.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/fast-sha256@1.3.0/node_modules/fast-sha256/sha256.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge@2.2.8/node_modules/@automerge/automerge/dist/mjs/constants.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge@2.2.8/node_modules/@automerge/automerge/dist/mjs/text.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge@2.2.8/node_modules/@automerge/automerge/dist/mjs/counter.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge@2.2.8/node_modules/@automerge/automerge/dist/mjs/raw_string.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge@2.2.8/node_modules/@automerge/automerge/dist/mjs/proxies.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge@2.2.8/node_modules/@automerge/automerge/dist/mjs/uuid.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge@2.2.8/node_modules/@automerge/automerge/dist/mjs/wasm_bindgen_output/web/automerge_wasm.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge@2.2.8/node_modules/@automerge/automerge/dist/mjs/stable.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/DocHandle.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/AutomergeUrl.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/helpers/cbor.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/cbor-x@1.6.0/node_modules/cbor-x/decode.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/cbor-x@1.6.0/node_modules/cbor-x/encode.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/Repo.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/RemoteHeadsSubscriptions.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/network/NetworkSubsystem.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/storage/StorageSubsystem.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/storage/keyHash.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/synchronizer/CollectionSynchronizer.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/synchronizer/DocSynchronizer.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo/dist/network/NetworkAdapter.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/isomorphic-ws@5.0.0_ws@8.18.0/node_modules/isomorphic-ws/browser.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo-network-websocket@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo-network-websocket/dist/BrowserWebSocketClientAdapter.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo-network-websocket@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo-network-websocket/dist/messages.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo-network-websocket@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo-network-websocket/dist/protocolVersion.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo-network-websocket@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo-network-websocket/dist/assert.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo-network-websocket@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo-network-websocket/dist/toArrayBuffer.js","../esmd/npm/@automerge/automerge-repo-network-websocket@2.0.0-alpha.11/node_modules/.pnpm/@automerge+automerge-repo-network-websocket@2.0.0-alpha.11_@types+node@22.5.4_typescript@5.6.2/node_modules/@automerge/automerge-repo-network-websocket/dist/NodeWSServerAdapter.js"],"sourcesContent":["/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' \u0026\u0026 val.length \u003e 0) {\n    return parse(val);\n  } else if (type === 'number' \u0026\u0026 isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length \u003e 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs \u003e= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs \u003e= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs \u003e= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs \u003e= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs \u003e= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs \u003e= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs \u003e= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs \u003e= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs \u003e= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key =\u003e {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i \u003c namespace.length; i++) {\n\t\t\thash = ((hash \u003c\u003c 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) =\u003e {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () =\u003e {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v =\u003e {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i \u003c len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace =\u003e '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i \u003c len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i \u003c len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() =\u003e {\n\tlet warned = false;\n\n\treturn () =\u003e {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox \u003e= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' \u0026\u0026 window.process \u0026\u0026 (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' \u0026\u0026 navigator.userAgent \u0026\u0026 navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' \u0026\u0026 document.documentElement \u0026\u0026 document.documentElement.style \u0026\u0026 document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' \u0026\u0026 window.console \u0026\u0026 (window.console.firebug || (window.console.exception \u0026\u0026 window.console.table))) ||\n\t\t// Is firefox \u003e= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' \u0026\u0026 navigator.userAgent \u0026\u0026 (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) \u0026\u0026 parseInt(m[1], 10) \u003e= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' \u0026\u0026 navigator.userAgent \u0026\u0026 navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match =\u003e {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() =\u003e {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r \u0026\u0026 typeof process !== 'undefined' \u0026\u0026 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i \u003c l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i \u003c len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i \u003c length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j \u003c len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn \u0026\u0026\n      (!once || listeners.once) \u0026\u0026\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i \u003c length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once \u0026\u0026 !listeners[i].once) ||\n        (context \u0026\u0026 listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","function number(n: number) {\n  if (!Number.isSafeInteger(n) || n \u003c 0) throw new Error(`positive integer expected, not ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\n// copied from utils\nexport function isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null \u0026\u0026 typeof a === 'object' \u0026\u0026 a.constructor.name === 'Uint8Array')\n  );\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length \u003e 0 \u0026\u0026 !lengths.includes(b.length))\n    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(h: Hash) {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(h.outputLen);\n  number(h.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished \u0026\u0026 instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length \u003c min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n","// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record\u003cstring, any\u003e | undefined;\nexport const crypto =\n  typeof globalThis === 'object' \u0026\u0026 'crypto' in globalThis ? globalThis.crypto : undefined;\n","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null \u0026\u0026 typeof a === 'object' \u0026\u0026 a.constructor.name === 'Uint8Array')\n  );\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) =\u003e new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =\u003e\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =\u003e\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) =\u003e (word \u003c\u003c (32 - shift)) | (word \u003e\u003e\u003e shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word: number, shift: number) =\u003e\n  (word \u003c\u003c shift) | ((word \u003e\u003e\u003e (32 - shift)) \u003e\u003e\u003e 0);\n\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word: number) =\u003e\n  ((word \u003c\u003c 24) \u0026 0xff000000) |\n  ((word \u003c\u003c 8) \u0026 0xff0000) |\n  ((word \u003e\u003e\u003e 8) \u0026 0xff00) |\n  ((word \u003e\u003e\u003e 24) \u0026 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n: number) =\u003e n : (n: number) =\u003e byteSwap(n);\n\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr: Uint32Array) {\n  for (let i = 0; i \u003c arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =\u003e\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i \u003c bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char \u003e= asciis._0 \u0026\u0026 char \u003c= asciis._9) return char - asciis._0;\n  if (char \u003e= asciis._A \u0026\u0026 char \u003c= asciis._F) return char - (asciis._A - 10);\n  if (char \u003e= asciis._a \u0026\u0026 char \u003c= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai \u003c al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () =\u003e {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) =\u003e void) {\n  let ts = Date.now();\n  for (let i = 0; i \u003c iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff \u003e= 0 \u0026\u0026 diff \u003c tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i \u003c arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i \u003c arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash\u003cT extends Hash\u003cT\u003e\u003e {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance =\u003e all internal\n   * buffers are overwritten =\u003e causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF\u003cT extends Hash\u003cT\u003e\u003e = Hash\u003cT\u003e \u0026 {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts\u003cT1 extends EmptyObj, T2 extends EmptyObj\u003e(\n  defaults: T1,\n  opts?: T2\n): T1 \u0026 T2 {\n  if (opts !== undefined \u0026\u0026 toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 \u0026 T2;\n}\n\nexport type CHash = ReturnType\u003ctypeof wrapConstructor\u003e;\n\nexport function wrapConstructor\u003cT extends Hash\u003cT\u003e\u003e(hashCons: () =\u003e Hash\u003cT\u003e) {\n  const hashC = (msg: Input): Uint8Array =\u003e hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () =\u003e hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts\u003cH extends Hash\u003cH\u003e, T extends Object\u003e(\n  hashCons: (opts?: T) =\u003e Hash\u003cH\u003e\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array =\u003e hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) =\u003e hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts\u003cH extends HashXOF\u003cH\u003e, T extends Object\u003e(\n  hashCons: (opts?: T) =\u003e HashXOF\u003cH\u003e\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array =\u003e hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) =\u003e hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto \u0026\u0026 typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto \u0026\u0026 typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n/**\n * Polyfill for Safari 14\n */\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value \u003e\u003e _32n) \u0026 _u32_max);\n  const wl = Number(value \u0026 _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/**\n * Choice: a ? b : c\n */\nexport const Chi = (a: number, b: number, c: number) =\u003e (a \u0026 b) ^ (~a \u0026 c);\n\n/**\n * Majority function, true if any two inputs is true\n */\nexport const Maj = (a: number, b: number, c: number) =\u003e (a \u0026 b) ^ (a \u0026 c) ^ (b \u0026 c);\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD\u003cT extends HashMD\u003cT\u003e\u003e extends Hash\u003cT\u003e {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos \u003c len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen \u003c= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset \u003e blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i \u003c blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen \u003e state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i \u003c outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","import { HashMD, Chi, Maj } from './_md.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD\u003cSHA256\u003e {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = SHA256_IV[0] | 0;\n  B = SHA256_IV[1] | 0;\n  C = SHA256_IV[2] | 0;\n  D = SHA256_IV[3] | 0;\n  E = SHA256_IV[4] | 0;\n  F = SHA256_IV[5] | 0;\n  G = SHA256_IV[6] | 0;\n  H = SHA256_IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i \u003c 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i \u003c 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 \u003e\u003e\u003e 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 \u003e\u003e\u003e 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i \u003c 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() =\u003e new SHA256());\n/**\n * SHA2-224 hash function\n */\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() =\u003e new SHA224());\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length \u003e= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j \u003c BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i \u003c ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip \u0026 count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend \u0026\u0026 source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) \u003e\u003e\u003e 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i \u003c length) \u0026\u0026 (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) \u003e\u003e\u003e 0\n        b58[it1] = (carry % BASE) \u003e\u003e\u003e 0\n        carry = (carry / BASE) \u003e\u003e\u003e 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size \u0026\u0026 b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 \u003c size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) \u003e\u003e\u003e 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i \u003c length) \u0026\u0026 (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) \u003e\u003e\u003e 0\n        b256[it3] = (carry % 256) \u003e\u003e\u003e 0\n        carry = (carry / 256) \u003e\u003e\u003e 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size \u0026\u0026 b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","'use strict'\n\nvar base58 = require('bs58')\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var payloadU8 = Uint8Array.from(payload)\n    var checksum = checksumFn(payloadU8)\n    var length = payloadU8.length + 4\n    var both = new Uint8Array(length)\n    both.set(payloadU8, 0)\n    both.set(checksum.subarray(0, 4), payloadU8.length)\n    return base58.encode(both, length)\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar { sha256 } = require('@noble/hashes/sha256')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  return sha256(sha256(buffer))\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","(function (root, factory) {\n    // Hack to make all exports of this module sha256 function object properties.\n    var exports = {};\n    factory(exports);\n    var sha256 = exports[\"default\"];\n    for (var k in exports) {\n        sha256[k] = exports[k];\n    }\n        \n    if (typeof module === 'object' \u0026\u0026 typeof module.exports === 'object') {\n        module.exports = sha256;\n    } else if (typeof define === 'function' \u0026\u0026 define.amd) {\n        define(function() { return sha256; }); \n    } else {\n        root.sha256 = sha256;\n    }\n})(this, function(exports) {\n\"use strict\";\nexports.__esModule = true;\n// SHA-256 (+ HMAC and PBKDF2) for JavaScript.\n//\n// Written in 2014-2016 by Dmitry Chestnykh.\n// Public domain, no warranty.\n//\n// Functions (accept and return Uint8Arrays):\n//\n//   sha256(message) -\u003e hash\n//   sha256.hmac(key, message) -\u003e mac\n//   sha256.pbkdf2(password, salt, rounds, dkLen) -\u003e dk\n//\n//  Classes:\n//\n//   new sha256.Hash()\n//   new sha256.HMAC(key)\n//\nexports.digestLength = 32;\nexports.blockSize = 64;\n// SHA-256 constants\nvar K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\nfunction hashBlocks(w, v, p, pos, len) {\n    var a, b, c, d, e, f, g, h, u, i, j, t1, t2;\n    while (len \u003e= 64) {\n        a = v[0];\n        b = v[1];\n        c = v[2];\n        d = v[3];\n        e = v[4];\n        f = v[5];\n        g = v[6];\n        h = v[7];\n        for (i = 0; i \u003c 16; i++) {\n            j = pos + i * 4;\n            w[i] = (((p[j] \u0026 0xff) \u003c\u003c 24) | ((p[j + 1] \u0026 0xff) \u003c\u003c 16) |\n                ((p[j + 2] \u0026 0xff) \u003c\u003c 8) | (p[j + 3] \u0026 0xff));\n        }\n        for (i = 16; i \u003c 64; i++) {\n            u = w[i - 2];\n            t1 = (u \u003e\u003e\u003e 17 | u \u003c\u003c (32 - 17)) ^ (u \u003e\u003e\u003e 19 | u \u003c\u003c (32 - 19)) ^ (u \u003e\u003e\u003e 10);\n            u = w[i - 15];\n            t2 = (u \u003e\u003e\u003e 7 | u \u003c\u003c (32 - 7)) ^ (u \u003e\u003e\u003e 18 | u \u003c\u003c (32 - 18)) ^ (u \u003e\u003e\u003e 3);\n            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);\n        }\n        for (i = 0; i \u003c 64; i++) {\n            t1 = (((((e \u003e\u003e\u003e 6 | e \u003c\u003c (32 - 6)) ^ (e \u003e\u003e\u003e 11 | e \u003c\u003c (32 - 11)) ^\n                (e \u003e\u003e\u003e 25 | e \u003c\u003c (32 - 25))) + ((e \u0026 f) ^ (~e \u0026 g))) | 0) +\n                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n            t2 = (((a \u003e\u003e\u003e 2 | a \u003c\u003c (32 - 2)) ^ (a \u003e\u003e\u003e 13 | a \u003c\u003c (32 - 13)) ^\n                (a \u003e\u003e\u003e 22 | a \u003c\u003c (32 - 22))) + ((a \u0026 b) ^ (a \u0026 c) ^ (b \u0026 c))) | 0;\n            h = g;\n            g = f;\n            f = e;\n            e = (d + t1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (t1 + t2) | 0;\n        }\n        v[0] += a;\n        v[1] += b;\n        v[2] += c;\n        v[3] += d;\n        v[4] += e;\n        v[5] += f;\n        v[6] += g;\n        v[7] += h;\n        pos += 64;\n        len -= 64;\n    }\n    return pos;\n}\n// Hash implements SHA256 hash algorithm.\nvar Hash = /** @class */ (function () {\n    function Hash() {\n        this.digestLength = exports.digestLength;\n        this.blockSize = exports.blockSize;\n        // Note: Int32Array is used instead of Uint32Array for performance reasons.\n        this.state = new Int32Array(8); // hash state\n        this.temp = new Int32Array(64); // temporary state\n        this.buffer = new Uint8Array(128); // buffer for data to hash\n        this.bufferLength = 0; // number of bytes in buffer\n        this.bytesHashed = 0; // number of total bytes hashed\n        this.finished = false; // indicates whether the hash was finalized\n        this.reset();\n    }\n    // Resets hash state making it possible\n    // to re-use this instance to hash other data.\n    Hash.prototype.reset = function () {\n        this.state[0] = 0x6a09e667;\n        this.state[1] = 0xbb67ae85;\n        this.state[2] = 0x3c6ef372;\n        this.state[3] = 0xa54ff53a;\n        this.state[4] = 0x510e527f;\n        this.state[5] = 0x9b05688c;\n        this.state[6] = 0x1f83d9ab;\n        this.state[7] = 0x5be0cd19;\n        this.bufferLength = 0;\n        this.bytesHashed = 0;\n        this.finished = false;\n        return this;\n    };\n    // Cleans internal buffers and re-initializes hash state.\n    Hash.prototype.clean = function () {\n        for (var i = 0; i \u003c this.buffer.length; i++) {\n            this.buffer[i] = 0;\n        }\n        for (var i = 0; i \u003c this.temp.length; i++) {\n            this.temp[i] = 0;\n        }\n        this.reset();\n    };\n    // Updates hash state with the given data.\n    //\n    // Optionally, length of the data can be specified to hash\n    // fewer bytes than data.length.\n    //\n    // Throws error when trying to update already finalized hash:\n    // instance must be reset to use it again.\n    Hash.prototype.update = function (data, dataLength) {\n        if (dataLength === void 0) { dataLength = data.length; }\n        if (this.finished) {\n            throw new Error(\"SHA256: can't update because hash was finished.\");\n        }\n        var dataPos = 0;\n        this.bytesHashed += dataLength;\n        if (this.bufferLength \u003e 0) {\n            while (this.bufferLength \u003c 64 \u0026\u0026 dataLength \u003e 0) {\n                this.buffer[this.bufferLength++] = data[dataPos++];\n                dataLength--;\n            }\n            if (this.bufferLength === 64) {\n                hashBlocks(this.temp, this.state, this.buffer, 0, 64);\n                this.bufferLength = 0;\n            }\n        }\n        if (dataLength \u003e= 64) {\n            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);\n            dataLength %= 64;\n        }\n        while (dataLength \u003e 0) {\n            this.buffer[this.bufferLength++] = data[dataPos++];\n            dataLength--;\n        }\n        return this;\n    };\n    // Finalizes hash state and puts hash into out.\n    //\n    // If hash was already finalized, puts the same value.\n    Hash.prototype.finish = function (out) {\n        if (!this.finished) {\n            var bytesHashed = this.bytesHashed;\n            var left = this.bufferLength;\n            var bitLenHi = (bytesHashed / 0x20000000) | 0;\n            var bitLenLo = bytesHashed \u003c\u003c 3;\n            var padLength = (bytesHashed % 64 \u003c 56) ? 64 : 128;\n            this.buffer[left] = 0x80;\n            for (var i = left + 1; i \u003c padLength - 8; i++) {\n                this.buffer[i] = 0;\n            }\n            this.buffer[padLength - 8] = (bitLenHi \u003e\u003e\u003e 24) \u0026 0xff;\n            this.buffer[padLength - 7] = (bitLenHi \u003e\u003e\u003e 16) \u0026 0xff;\n            this.buffer[padLength - 6] = (bitLenHi \u003e\u003e\u003e 8) \u0026 0xff;\n            this.buffer[padLength - 5] = (bitLenHi \u003e\u003e\u003e 0) \u0026 0xff;\n            this.buffer[padLength - 4] = (bitLenLo \u003e\u003e\u003e 24) \u0026 0xff;\n            this.buffer[padLength - 3] = (bitLenLo \u003e\u003e\u003e 16) \u0026 0xff;\n            this.buffer[padLength - 2] = (bitLenLo \u003e\u003e\u003e 8) \u0026 0xff;\n            this.buffer[padLength - 1] = (bitLenLo \u003e\u003e\u003e 0) \u0026 0xff;\n            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);\n            this.finished = true;\n        }\n        for (var i = 0; i \u003c 8; i++) {\n            out[i * 4 + 0] = (this.state[i] \u003e\u003e\u003e 24) \u0026 0xff;\n            out[i * 4 + 1] = (this.state[i] \u003e\u003e\u003e 16) \u0026 0xff;\n            out[i * 4 + 2] = (this.state[i] \u003e\u003e\u003e 8) \u0026 0xff;\n            out[i * 4 + 3] = (this.state[i] \u003e\u003e\u003e 0) \u0026 0xff;\n        }\n        return this;\n    };\n    // Returns the final hash digest.\n    Hash.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._saveState = function (out) {\n        for (var i = 0; i \u003c this.state.length; i++) {\n            out[i] = this.state[i];\n        }\n    };\n    // Internal function for use in HMAC for optimization.\n    Hash.prototype._restoreState = function (from, bytesHashed) {\n        for (var i = 0; i \u003c this.state.length; i++) {\n            this.state[i] = from[i];\n        }\n        this.bytesHashed = bytesHashed;\n        this.finished = false;\n        this.bufferLength = 0;\n    };\n    return Hash;\n}());\nexports.Hash = Hash;\n// HMAC implements HMAC-SHA256 message authentication algorithm.\nvar HMAC = /** @class */ (function () {\n    function HMAC(key) {\n        this.inner = new Hash();\n        this.outer = new Hash();\n        this.blockSize = this.inner.blockSize;\n        this.digestLength = this.inner.digestLength;\n        var pad = new Uint8Array(this.blockSize);\n        if (key.length \u003e this.blockSize) {\n            (new Hash()).update(key).finish(pad).clean();\n        }\n        else {\n            for (var i = 0; i \u003c key.length; i++) {\n                pad[i] = key[i];\n            }\n        }\n        for (var i = 0; i \u003c pad.length; i++) {\n            pad[i] ^= 0x36;\n        }\n        this.inner.update(pad);\n        for (var i = 0; i \u003c pad.length; i++) {\n            pad[i] ^= 0x36 ^ 0x5c;\n        }\n        this.outer.update(pad);\n        this.istate = new Uint32Array(8);\n        this.ostate = new Uint32Array(8);\n        this.inner._saveState(this.istate);\n        this.outer._saveState(this.ostate);\n        for (var i = 0; i \u003c pad.length; i++) {\n            pad[i] = 0;\n        }\n    }\n    // Returns HMAC state to the state initialized with key\n    // to make it possible to run HMAC over the other data with the same\n    // key without creating a new instance.\n    HMAC.prototype.reset = function () {\n        this.inner._restoreState(this.istate, this.inner.blockSize);\n        this.outer._restoreState(this.ostate, this.outer.blockSize);\n        return this;\n    };\n    // Cleans HMAC state.\n    HMAC.prototype.clean = function () {\n        for (var i = 0; i \u003c this.istate.length; i++) {\n            this.ostate[i] = this.istate[i] = 0;\n        }\n        this.inner.clean();\n        this.outer.clean();\n    };\n    // Updates state with provided data.\n    HMAC.prototype.update = function (data) {\n        this.inner.update(data);\n        return this;\n    };\n    // Finalizes HMAC and puts the result in out.\n    HMAC.prototype.finish = function (out) {\n        if (this.outer.finished) {\n            this.outer.finish(out);\n        }\n        else {\n            this.inner.finish(out);\n            this.outer.update(out, this.digestLength).finish(out);\n        }\n        return this;\n    };\n    // Returns message authentication code.\n    HMAC.prototype.digest = function () {\n        var out = new Uint8Array(this.digestLength);\n        this.finish(out);\n        return out;\n    };\n    return HMAC;\n}());\nexports.HMAC = HMAC;\n// Returns SHA256 hash of data.\nfunction hash(data) {\n    var h = (new Hash()).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hash = hash;\n// Function hash is both available as module.hash and as default export.\nexports[\"default\"] = hash;\n// Returns HMAC-SHA256 of data under the key.\nfunction hmac(key, data) {\n    var h = (new HMAC(key)).update(data);\n    var digest = h.digest();\n    h.clean();\n    return digest;\n}\nexports.hmac = hmac;\n// Fills hkdf buffer like this:\n// T(1) = HMAC-Hash(PRK, T(0) | info | 0x01)\nfunction fillBuffer(buffer, hmac, info, counter) {\n    // Counter is a byte value: check if it overflowed.\n    var num = counter[0];\n    if (num === 0) {\n        throw new Error(\"hkdf: cannot expand more\");\n    }\n    // Prepare HMAC instance for new data with old key.\n    hmac.reset();\n    // Hash in previous output if it was generated\n    // (i.e. counter is greater than 1).\n    if (num \u003e 1) {\n        hmac.update(buffer);\n    }\n    // Hash in info if it exists.\n    if (info) {\n        hmac.update(info);\n    }\n    // Hash in the counter.\n    hmac.update(counter);\n    // Output result to buffer and clean HMAC instance.\n    hmac.finish(buffer);\n    // Increment counter inside typed array, this works properly.\n    counter[0]++;\n}\nvar hkdfSalt = new Uint8Array(exports.digestLength); // Filled with zeroes.\nfunction hkdf(key, salt, info, length) {\n    if (salt === void 0) { salt = hkdfSalt; }\n    if (length === void 0) { length = 32; }\n    var counter = new Uint8Array([1]);\n    // HKDF-Extract uses salt as HMAC key, and key as data.\n    var okm = hmac(salt, key);\n    // Initialize HMAC for expanding with extracted key.\n    // Ensure no collisions with `hmac` function.\n    var hmac_ = new HMAC(okm);\n    // Allocate buffer.\n    var buffer = new Uint8Array(hmac_.digestLength);\n    var bufpos = buffer.length;\n    var out = new Uint8Array(length);\n    for (var i = 0; i \u003c length; i++) {\n        if (bufpos === buffer.length) {\n            fillBuffer(buffer, hmac_, info, counter);\n            bufpos = 0;\n        }\n        out[i] = buffer[bufpos++];\n    }\n    hmac_.clean();\n    buffer.fill(0);\n    counter.fill(0);\n    return out;\n}\nexports.hkdf = hkdf;\n// Derives a key from password and salt using PBKDF2-HMAC-SHA256\n// with the given number of iterations.\n//\n// The number of bytes returned is equal to dkLen.\n//\n// (For better security, avoid dkLen greater than hash length - 32 bytes).\nfunction pbkdf2(password, salt, iterations, dkLen) {\n    var prf = new HMAC(password);\n    var len = prf.digestLength;\n    var ctr = new Uint8Array(4);\n    var t = new Uint8Array(len);\n    var u = new Uint8Array(len);\n    var dk = new Uint8Array(dkLen);\n    for (var i = 0; i * len \u003c dkLen; i++) {\n        var c = i + 1;\n        ctr[0] = (c \u003e\u003e\u003e 24) \u0026 0xff;\n        ctr[1] = (c \u003e\u003e\u003e 16) \u0026 0xff;\n        ctr[2] = (c \u003e\u003e\u003e 8) \u0026 0xff;\n        ctr[3] = (c \u003e\u003e\u003e 0) \u0026 0xff;\n        prf.reset();\n        prf.update(salt);\n        prf.update(ctr);\n        prf.finish(u);\n        for (var j = 0; j \u003c len; j++) {\n            t[j] = u[j];\n        }\n        for (var j = 2; j \u003c= iterations; j++) {\n            prf.reset();\n            prf.update(u).finish(u);\n            for (var k = 0; k \u003c len; k++) {\n                t[k] ^= u[k];\n            }\n        }\n        for (var j = 0; j \u003c len \u0026\u0026 i * len + j \u003c dkLen; j++) {\n            dk[i * len + j] = t[j];\n        }\n    }\n    for (var i = 0; i \u003c len; i++) {\n        t[i] = u[i] = 0;\n    }\n    for (var i = 0; i \u003c 4; i++) {\n        ctr[i] = 0;\n    }\n    prf.clean();\n    return dk;\n}\nexports.pbkdf2 = pbkdf2;\n});\n","// Properties of the document root object\nexport const STATE = Symbol.for(\"_am_meta\"); // symbol used to hide application metadata on automerge objects\nexport const TRACE = Symbol.for(\"_am_trace\"); // used for debugging\nexport const OBJECT_ID = Symbol.for(\"_am_objectId\"); // symbol used to hide the object id on automerge objects\nexport const IS_PROXY = Symbol.for(\"_am_isProxy\"); // symbol used to test if the document is a proxy object\nexport const CLEAR_CACHE = Symbol.for(\"_am_clearCache\"); // symbol used to tell a proxy object to clear its cache\nexport const UINT = Symbol.for(\"_am_uint\");\nexport const INT = Symbol.for(\"_am_int\");\nexport const F64 = Symbol.for(\"_am_f64\");\nexport const COUNTER = Symbol.for(\"_am_counter\");\nexport const TEXT = Symbol.for(\"_am_text\");\n","import { TEXT, STATE } from \"./constants.js\";\nexport class Text {\n    constructor(text) {\n        if (typeof text === \"string\") {\n            this.elems = [...text];\n        }\n        else if (Array.isArray(text)) {\n            this.elems = text;\n        }\n        else if (text === undefined) {\n            this.elems = [];\n        }\n        else {\n            throw new TypeError(`Unsupported initial value for Text: ${text}`);\n        }\n        Reflect.defineProperty(this, TEXT, { value: true });\n    }\n    get length() {\n        return this.elems.length;\n    }\n    //eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(index) {\n        return this.elems[index];\n    }\n    /**\n     * Iterates over the text elements character by character, including any\n     * inline objects.\n     */\n    [Symbol.iterator]() {\n        const elems = this.elems;\n        let index = -1;\n        return {\n            next() {\n                index += 1;\n                if (index \u003c elems.length) {\n                    return { done: false, value: elems[index] };\n                }\n                else {\n                    return { done: true };\n                }\n            },\n        };\n    }\n    /**\n     * Returns the content of the Text object as a simple string, ignoring any\n     * non-character elements.\n     */\n    toString() {\n        if (!this.str) {\n            // Concatting to a string is faster than creating an array and then\n            // .join()ing for small (\u003c100KB) arrays.\n            // https://jsperf.com/join-vs-loop-w-type-test\n            this.str = \"\";\n            for (const elem of this.elems) {\n                if (typeof elem === \"string\")\n                    this.str += elem;\n                else\n                    this.str += \"\\uFFFC\";\n            }\n        }\n        return this.str;\n    }\n    /**\n     * Returns the content of the Text object as a sequence of strings,\n     * interleaved with non-character elements.\n     *\n     * For example, the value `['a', 'b', {x: 3}, 'c', 'd']` has spans:\n     * `=\u003e ['ab', {x: 3}, 'cd']`\n     */\n    toSpans() {\n        if (!this.spans) {\n            this.spans = [];\n            let chars = \"\";\n            for (const elem of this.elems) {\n                if (typeof elem === \"string\") {\n                    chars += elem;\n                }\n                else {\n                    if (chars.length \u003e 0) {\n                        this.spans.push(chars);\n                        chars = \"\";\n                    }\n                    this.spans.push(elem);\n                }\n            }\n            if (chars.length \u003e 0) {\n                this.spans.push(chars);\n            }\n        }\n        return this.spans;\n    }\n    /**\n     * Returns the content of the Text object as a simple string, so that the\n     * JSON serialization of an Automerge document represents text nicely.\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Updates the list item at position `index` to a new value `value`.\n     */\n    set(index, value) {\n        if (this[STATE]) {\n            throw new RangeError(\"object cannot be modified outside of a change block\");\n        }\n        this.elems[index] = value;\n    }\n    /**\n     * Inserts new list items `values` starting at position `index`.\n     */\n    insertAt(index, ...values) {\n        if (this[STATE]) {\n            throw new RangeError(\"object cannot be modified outside of a change block\");\n        }\n        if (values.every(v =\u003e typeof v === \"string\")) {\n            this.elems.splice(index, 0, ...values.join(\"\"));\n        }\n        else {\n            this.elems.splice(index, 0, ...values);\n        }\n    }\n    /**\n     * Deletes `numDelete` list items starting at position `index`.\n     * if `numDelete` is not given, one item is deleted.\n     */\n    deleteAt(index, numDelete = 1) {\n        if (this[STATE]) {\n            throw new RangeError(\"object cannot be modified outside of a change block\");\n        }\n        this.elems.splice(index, numDelete);\n    }\n    map(callback) {\n        this.elems.map(callback);\n    }\n    lastIndexOf(searchElement, fromIndex) {\n        this.elems.lastIndexOf(searchElement, fromIndex);\n    }\n    concat(other) {\n        return new Text(this.elems.concat(other.elems));\n    }\n    every(test) {\n        return this.elems.every(test);\n    }\n    filter(test) {\n        return new Text(this.elems.filter(test));\n    }\n    find(test) {\n        return this.elems.find(test);\n    }\n    findIndex(test) {\n        return this.elems.findIndex(test);\n    }\n    forEach(f) {\n        this.elems.forEach(f);\n    }\n    includes(elem) {\n        return this.elems.includes(elem);\n    }\n    indexOf(elem) {\n        return this.elems.indexOf(elem);\n    }\n    join(sep) {\n        return this.elems.join(sep);\n    }\n    reduce(f) {\n        this.elems.reduce(f);\n    }\n    reduceRight(f) {\n        this.elems.reduceRight(f);\n    }\n    slice(start, end) {\n        return new Text(this.elems.slice(start, end));\n    }\n    some(test) {\n        return this.elems.some(test);\n    }\n    toLocaleString() {\n        this.toString();\n    }\n}\n","import { COUNTER } from \"./constants.js\";\n/**\n * The most basic CRDT: an integer value that can be changed only by\n * incrementing and decrementing. Since addition of integers is commutative,\n * the value trivially converges.\n */\nexport class Counter {\n    constructor(value) {\n        this.value = value || 0;\n        Reflect.defineProperty(this, COUNTER, { value: true });\n    }\n    /**\n     * A peculiar JavaScript language feature from its early days: if the object\n     * `x` has a `valueOf()` method that returns a number, you can use numerical\n     * operators on the object `x` directly, such as `x + 1` or `x \u003c 4`.\n     * This method is also called when coercing a value to a string by\n     * concatenating it with another string, as in `x + ''`.\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\n     */\n    valueOf() {\n        return this.value;\n    }\n    /**\n     * Returns the counter value as a decimal string. If `x` is a counter object,\n     * this method is called e.g. when you do `['value: ', x].join('')` or when\n     * you use string interpolation: `value: ${x}`.\n     */\n    toString() {\n        return this.valueOf().toString();\n    }\n    /**\n     * Returns the counter value, so that a JSON serialization of an Automerge\n     * document represents the counter simply as an integer.\n     */\n    toJSON() {\n        return this.value;\n    }\n    /**\n     * Increases the value of the counter by `delta`. If `delta` is not given,\n     * increases the value of the counter by 1.\n     *\n     * Will throw an error if used outside of a change callback.\n     */\n    increment(_delta) {\n        throw new Error(\"Counters should not be incremented outside of a change callback\");\n    }\n    /**\n     * Decreases the value of the counter by `delta`. If `delta` is not given,\n     * decreases the value of the counter by 1.\n     *\n     * Will throw an error if used outside of a change callback.\n     */\n    decrement(_delta) {\n        throw new Error(\"Counters should not be decremented outside of a change callback\");\n    }\n}\n/**\n * An instance of this class is used when a counter is accessed within a change\n * callback.\n */\nclass WriteableCounter extends Counter {\n    constructor(value, context, path, objectId, key) {\n        super(value);\n        this.context = context;\n        this.path = path;\n        this.objectId = objectId;\n        this.key = key;\n    }\n    /**\n     * Increases the value of the counter by `delta`. If `delta` is not given,\n     * increases the value of the counter by 1.\n     */\n    increment(delta) {\n        delta = typeof delta === \"number\" ? delta : 1;\n        this.context.increment(this.objectId, this.key, delta);\n        this.value += delta;\n        return this.value;\n    }\n    /**\n     * Decreases the value of the counter by `delta`. If `delta` is not given,\n     * decreases the value of the counter by 1.\n     */\n    decrement(delta) {\n        return this.increment(typeof delta === \"number\" ? -delta : -1);\n    }\n}\n/**\n * Returns an instance of `WriteableCounter` for use in a change callback.\n * `context` is the proxy context that keeps track of the mutations.\n * `objectId` is the ID of the object containing the counter, and `key` is\n * the property name (key in map, or index in list) where the counter is\n * located.\n */\nexport function getWriteableCounter(value, context, path, objectId, key) {\n    return new WriteableCounter(value, context, path, objectId, key);\n}\n//module.exports = { Counter, getWriteableCounter }\n","export class RawString {\n    constructor(val) {\n        this.val = val;\n    }\n    /**\n     * Returns the content of the RawString object as a simple string\n     */\n    toString() {\n        return this.val;\n    }\n    toJSON() {\n        return this.val;\n    }\n}\n","/* eslint-disable  @typescript-eslint/no-explicit-any */\nimport { Text } from \"./text.js\";\nimport { getWriteableCounter } from \"./counter.js\";\nimport { STATE, TRACE, IS_PROXY, OBJECT_ID, CLEAR_CACHE, COUNTER, INT, UINT, F64, } from \"./constants.js\";\nimport { RawString } from \"./raw_string.js\";\nfunction parseListIndex(key) {\n    if (typeof key === \"string\" \u0026\u0026 /^[0-9]+$/.test(key))\n        key = parseInt(key, 10);\n    if (typeof key !== \"number\") {\n        return key;\n    }\n    if (key \u003c 0 || isNaN(key) || key === Infinity || key === -Infinity) {\n        throw new RangeError(\"A list index must be positive, but you passed \" + key);\n    }\n    return key;\n}\nfunction valueAt(target, prop) {\n    const { context, objectId, path, textV2 } = target;\n    const value = context.getWithType(objectId, prop);\n    if (value === null) {\n        return;\n    }\n    const datatype = value[0];\n    const val = value[1];\n    switch (datatype) {\n        case undefined:\n            return;\n        case \"map\":\n            return mapProxy(context, val, textV2, [...path, prop]);\n        case \"list\":\n            return listProxy(context, val, textV2, [...path, prop]);\n        case \"text\":\n            if (textV2) {\n                return context.text(val);\n            }\n            else {\n                return textProxy(context, val, [\n                    ...path,\n                    prop,\n                ]);\n            }\n        case \"str\":\n            return val;\n        case \"uint\":\n            return val;\n        case \"int\":\n            return val;\n        case \"f64\":\n            return val;\n        case \"boolean\":\n            return val;\n        case \"null\":\n            return null;\n        case \"bytes\":\n            return val;\n        case \"timestamp\":\n            return val;\n        case \"counter\": {\n            const counter = getWriteableCounter(val, context, path, objectId, prop);\n            return counter;\n        }\n        default:\n            throw RangeError(`datatype ${datatype} unimplemented`);\n    }\n}\nfunction import_value(value, textV2, path, context) {\n    const type = typeof value;\n    switch (type) {\n        case \"object\":\n            if (value == null) {\n                return [null, \"null\"];\n            }\n            else if (value[UINT]) {\n                return [value.value, \"uint\"];\n            }\n            else if (value[INT]) {\n                return [value.value, \"int\"];\n            }\n            else if (value[F64]) {\n                return [value.value, \"f64\"];\n            }\n            else if (value[COUNTER]) {\n                return [value.value, \"counter\"];\n            }\n            else if (value instanceof Date) {\n                return [value.getTime(), \"timestamp\"];\n            }\n            else if (value instanceof RawString) {\n                return [value.toString(), \"str\"];\n            }\n            else if (value instanceof Text) {\n                return [value, \"text\"];\n            }\n            else if (value instanceof Uint8Array) {\n                return [value, \"bytes\"];\n            }\n            else if (value instanceof Array) {\n                return [value, \"list\"];\n            }\n            else if (Object.prototype.toString.call(value) === \"[object Object]\") {\n                return [value, \"map\"];\n            }\n            else if (isSameDocument(value, context)) {\n                throw new RangeError(\"Cannot create a reference to an existing document object\");\n            }\n            else {\n                throw new RangeError(`Cannot assign unknown object: ${value}`);\n            }\n        case \"boolean\":\n            return [value, \"boolean\"];\n        case \"number\":\n            if (Number.isInteger(value)) {\n                return [value, \"int\"];\n            }\n            else {\n                return [value, \"f64\"];\n            }\n        case \"string\":\n            if (textV2) {\n                return [value, \"text\"];\n            }\n            else {\n                return [value, \"str\"];\n            }\n        case \"undefined\":\n            throw new RangeError([\n                `Cannot assign undefined value at ${printPath(path)}, `,\n                \"because `undefined` is not a valid JSON data type. \",\n                \"You might consider setting the property's value to `null`, \",\n                \"or using `delete` to remove it altogether.\",\n            ].join(\"\"));\n        default:\n            throw new RangeError([\n                `Cannot assign ${type} value at ${printPath(path)}. `,\n                `All JSON primitive datatypes (object, array, string, number, boolean, null) `,\n                `are supported in an Automerge document; ${type} values are not. `,\n            ].join(\"\"));\n    }\n}\n// When we assign a value to a property in a proxy we recursively walk through\n// the value we are assigning and copy it into the document. This is generally\n// desirable behaviour. However, a very common bug is to accidentally assign a\n// value which is already in the document to another key within the same\n// document, this often leads to surprising behaviour where users expected to\n// _move_ the object, but it is instead copied. To avoid this we check if the\n// value is from the same document and if it is we throw an error, this means\n// we require an explicit Object.assign call to copy the object, thus avoiding\n// the footgun\nfunction isSameDocument(val, context) {\n    var _b, _c;\n    // Date is technically an object, but immutable, so allowing people to assign\n    // a date from one place in the document to another place in the document is\n    // not likely to be a bug\n    if (val instanceof Date) {\n        return false;\n    }\n    // this depends on __wbg_ptr being the wasm pointer\n    // a new version of wasm-bindgen will break this\n    // but the tests should expose the break\n    if (val \u0026\u0026 ((_c = (_b = val[STATE]) === null || _b === void 0 ? void 0 : _b.handle) === null || _c === void 0 ? void 0 : _c.__wbg_ptr) === context.__wbg_ptr) {\n        return true;\n    }\n    return false;\n}\nconst MapHandler = {\n    get(target, key) {\n        const { context, objectId, cache } = target;\n        if (key === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (key === OBJECT_ID)\n            return objectId;\n        if (key === IS_PROXY)\n            return true;\n        if (key === TRACE)\n            return target.trace;\n        if (key === STATE)\n            return { handle: context, textV2: target.textV2 };\n        if (!cache[key]) {\n            cache[key] = valueAt(target, key);\n        }\n        return cache[key];\n    },\n    set(target, key, val) {\n        const { context, objectId, path, textV2 } = target;\n        target.cache = {}; // reset cache on set\n        if (isSameDocument(val, context)) {\n            throw new RangeError(\"Cannot create a reference to an existing document object\");\n        }\n        if (key === TRACE) {\n            target.trace = val;\n            return true;\n        }\n        if (key === CLEAR_CACHE) {\n            return true;\n        }\n        const [value, datatype] = import_value(val, textV2, [...path, key], context);\n        switch (datatype) {\n            case \"list\": {\n                const list = context.putObject(objectId, key, []);\n                const proxyList = listProxy(context, list, textV2, [...path, key]);\n                for (let i = 0; i \u003c value.length; i++) {\n                    proxyList[i] = value[i];\n                }\n                break;\n            }\n            case \"text\": {\n                if (textV2) {\n                    assertString(value);\n                    context.putObject(objectId, key, value);\n                }\n                else {\n                    assertText(value);\n                    const text = context.putObject(objectId, key, \"\");\n                    const proxyText = textProxy(context, text, [...path, key]);\n                    proxyText.splice(0, 0, ...value);\n                }\n                break;\n            }\n            case \"map\": {\n                const map = context.putObject(objectId, key, {});\n                const proxyMap = mapProxy(context, map, textV2, [...path, key]);\n                for (const key in value) {\n                    proxyMap[key] = value[key];\n                }\n                break;\n            }\n            default:\n                context.put(objectId, key, value, datatype);\n        }\n        return true;\n    },\n    deleteProperty(target, key) {\n        const { context, objectId } = target;\n        target.cache = {}; // reset cache on delete\n        context.delete(objectId, key);\n        return true;\n    },\n    has(target, key) {\n        const value = this.get(target, key);\n        return value !== undefined;\n    },\n    getOwnPropertyDescriptor(target, key) {\n        // const { context, objectId } = target\n        const value = this.get(target, key);\n        if (typeof value !== \"undefined\") {\n            return {\n                configurable: true,\n                enumerable: true,\n                value,\n            };\n        }\n    },\n    ownKeys(target) {\n        const { context, objectId } = target;\n        // FIXME - this is a tmp workaround until fix the dupe key bug in keys()\n        const keys = context.keys(objectId);\n        return [...new Set(keys)];\n    },\n};\nconst ListHandler = {\n    get(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        if (index === Symbol.hasInstance) {\n            return (instance) =\u003e {\n                return Array.isArray(instance);\n            };\n        }\n        if (index === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (index === OBJECT_ID)\n            return objectId;\n        if (index === IS_PROXY)\n            return true;\n        if (index === TRACE)\n            return target.trace;\n        if (index === STATE)\n            return { handle: context };\n        if (index === \"length\")\n            return context.length(objectId);\n        if (typeof index === \"number\") {\n            return valueAt(target, index);\n        }\n        else {\n            return listMethods(target)[index];\n        }\n    },\n    set(target, index, val) {\n        const { context, objectId, path, textV2 } = target;\n        index = parseListIndex(index);\n        if (isSameDocument(val, context)) {\n            throw new RangeError(\"Cannot create a reference to an existing document object\");\n        }\n        if (index === CLEAR_CACHE) {\n            return true;\n        }\n        if (index === TRACE) {\n            target.trace = val;\n            return true;\n        }\n        if (typeof index == \"string\") {\n            throw new RangeError(\"list index must be a number\");\n        }\n        const [value, datatype] = import_value(val, textV2, [...path, index], context);\n        switch (datatype) {\n            case \"list\": {\n                let list;\n                if (index \u003e= context.length(objectId)) {\n                    list = context.insertObject(objectId, index, []);\n                }\n                else {\n                    list = context.putObject(objectId, index, []);\n                }\n                const proxyList = listProxy(context, list, textV2, [...path, index]);\n                proxyList.splice(0, 0, ...value);\n                break;\n            }\n            case \"text\": {\n                if (textV2) {\n                    assertString(value);\n                    if (index \u003e= context.length(objectId)) {\n                        context.insertObject(objectId, index, value);\n                    }\n                    else {\n                        context.putObject(objectId, index, value);\n                    }\n                }\n                else {\n                    let text;\n                    assertText(value);\n                    if (index \u003e= context.length(objectId)) {\n                        text = context.insertObject(objectId, index, \"\");\n                    }\n                    else {\n                        text = context.putObject(objectId, index, \"\");\n                    }\n                    const proxyText = textProxy(context, text, [...path, index]);\n                    proxyText.splice(0, 0, ...value);\n                }\n                break;\n            }\n            case \"map\": {\n                let map;\n                if (index \u003e= context.length(objectId)) {\n                    map = context.insertObject(objectId, index, {});\n                }\n                else {\n                    map = context.putObject(objectId, index, {});\n                }\n                const proxyMap = mapProxy(context, map, textV2, [...path, index]);\n                for (const key in value) {\n                    proxyMap[key] = value[key];\n                }\n                break;\n            }\n            default:\n                if (index \u003e= context.length(objectId)) {\n                    context.insert(objectId, index, value, datatype);\n                }\n                else {\n                    context.put(objectId, index, value, datatype);\n                }\n        }\n        return true;\n    },\n    deleteProperty(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        const elem = context.get(objectId, index);\n        if (elem != null \u0026\u0026 elem[0] == \"counter\") {\n            throw new TypeError(\"Unsupported operation: deleting a counter from a list\");\n        }\n        context.delete(objectId, index);\n        return true;\n    },\n    has(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        if (typeof index === \"number\") {\n            return index \u003c context.length(objectId);\n        }\n        return index === \"length\";\n    },\n    getOwnPropertyDescriptor(target, index) {\n        const { context, objectId } = target;\n        if (index === \"length\")\n            return { writable: true, value: context.length(objectId) };\n        if (index === OBJECT_ID)\n            return { configurable: false, enumerable: false, value: objectId };\n        index = parseListIndex(index);\n        const value = valueAt(target, index);\n        return { configurable: true, enumerable: true, value };\n    },\n    getPrototypeOf(target) {\n        return Object.getPrototypeOf(target);\n    },\n    ownKeys( /*target*/) {\n        const keys = [];\n        // uncommenting this causes assert.deepEqual() to fail when comparing to a pojo array\n        // but not uncommenting it causes for (i in list) {} to not enumerate values properly\n        //const {context, objectId } = target\n        //for (let i = 0; i \u003c target.context.length(objectId); i++) { keys.push(i.toString()) }\n        keys.push(\"length\");\n        return keys;\n    },\n};\nconst TextHandler = Object.assign({}, ListHandler, {\n    get(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        if (index === Symbol.hasInstance) {\n            return (instance) =\u003e {\n                return Array.isArray(instance);\n            };\n        }\n        if (index === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (index === OBJECT_ID)\n            return objectId;\n        if (index === IS_PROXY)\n            return true;\n        if (index === TRACE)\n            return target.trace;\n        if (index === STATE)\n            return { handle: context };\n        if (index === \"length\")\n            return context.length(objectId);\n        if (typeof index === \"number\") {\n            return valueAt(target, index);\n        }\n        else {\n            return textMethods(target)[index] || listMethods(target)[index];\n        }\n    },\n    getPrototypeOf( /*target*/) {\n        return Object.getPrototypeOf(new Text());\n    },\n});\nexport function mapProxy(context, objectId, textV2, path) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        cache: {},\n        textV2,\n    };\n    const proxied = {};\n    Object.assign(proxied, target);\n    const result = new Proxy(proxied, MapHandler);\n    // conversion through unknown is necessary because the types are so different\n    return result;\n}\nexport function listProxy(context, objectId, textV2, path) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        cache: {},\n        textV2,\n    };\n    const proxied = [];\n    Object.assign(proxied, target);\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new Proxy(proxied, ListHandler);\n}\nexport function textProxy(context, objectId, path) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        cache: {},\n        textV2: false,\n    };\n    const proxied = {};\n    Object.assign(proxied, target);\n    return new Proxy(proxied, TextHandler);\n}\nexport function rootProxy(context, textV2) {\n    /* eslint-disable-next-line */\n    return mapProxy(context, \"_root\", textV2, []);\n}\nfunction listMethods(target) {\n    const { context, objectId, path, textV2 } = target;\n    const methods = {\n        deleteAt(index, numDelete) {\n            if (typeof numDelete === \"number\") {\n                context.splice(objectId, index, numDelete);\n            }\n            else {\n                context.delete(objectId, index);\n            }\n            return this;\n        },\n        fill(val, start, end) {\n            const [value, datatype] = import_value(val, textV2, [...path, start], context);\n            const length = context.length(objectId);\n            start = parseListIndex(start || 0);\n            end = parseListIndex(end || length);\n            for (let i = start; i \u003c Math.min(end, length); i++) {\n                if (datatype === \"list\" || datatype === \"map\") {\n                    context.putObject(objectId, i, value);\n                }\n                else if (datatype === \"text\") {\n                    if (textV2) {\n                        assertString(value);\n                        context.putObject(objectId, i, value);\n                    }\n                    else {\n                        assertText(value);\n                        const text = context.putObject(objectId, i, \"\");\n                        const proxyText = textProxy(context, text, [...path, i]);\n                        for (let i = 0; i \u003c value.length; i++) {\n                            proxyText[i] = value.get(i);\n                        }\n                    }\n                }\n                else {\n                    context.put(objectId, i, value, datatype);\n                }\n            }\n            return this;\n        },\n        indexOf(o, start = 0) {\n            const length = context.length(objectId);\n            for (let i = start; i \u003c length; i++) {\n                const value = context.getWithType(objectId, i);\n                if (value \u0026\u0026 (value[1] === o[OBJECT_ID] || value[1] === o)) {\n                    return i;\n                }\n            }\n            return -1;\n        },\n        insertAt(index, ...values) {\n            this.splice(index, 0, ...values);\n            return this;\n        },\n        pop() {\n            const length = context.length(objectId);\n            if (length == 0) {\n                return undefined;\n            }\n            const last = valueAt(target, length - 1);\n            context.delete(objectId, length - 1);\n            return last;\n        },\n        push(...values) {\n            const len = context.length(objectId);\n            this.splice(len, 0, ...values);\n            return context.length(objectId);\n        },\n        shift() {\n            if (context.length(objectId) == 0)\n                return;\n            const first = valueAt(target, 0);\n            context.delete(objectId, 0);\n            return first;\n        },\n        splice(index, del, ...vals) {\n            index = parseListIndex(index);\n            // if del is undefined, delete until the end of the list\n            if (typeof del !== \"number\") {\n                del = context.length(objectId) - index;\n            }\n            del = parseListIndex(del);\n            for (const val of vals) {\n                if (isSameDocument(val, context)) {\n                    throw new RangeError(\"Cannot create a reference to an existing document object\");\n                }\n            }\n            const result = [];\n            for (let i = 0; i \u003c del; i++) {\n                const value = valueAt(target, index);\n                if (value !== undefined) {\n                    result.push(value);\n                }\n                context.delete(objectId, index);\n            }\n            const values = vals.map((val, index) =\u003e {\n                try {\n                    return import_value(val, textV2, [...path], context);\n                }\n                catch (e) {\n                    if (e instanceof RangeError) {\n                        throw new RangeError(`${e.message} (at index ${index} in the input)`);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            });\n            for (const [value, datatype] of values) {\n                switch (datatype) {\n                    case \"list\": {\n                        const list = context.insertObject(objectId, index, []);\n                        const proxyList = listProxy(context, list, textV2, [...path, index]);\n                        proxyList.splice(0, 0, ...value);\n                        break;\n                    }\n                    case \"text\": {\n                        if (textV2) {\n                            assertString(value);\n                            context.insertObject(objectId, index, value);\n                        }\n                        else {\n                            const text = context.insertObject(objectId, index, \"\");\n                            const proxyText = textProxy(context, text, [...path, index]);\n                            proxyText.splice(0, 0, ...value);\n                        }\n                        break;\n                    }\n                    case \"map\": {\n                        const map = context.insertObject(objectId, index, {});\n                        const proxyMap = mapProxy(context, map, textV2, [...path, index]);\n                        for (const key in value) {\n                            proxyMap[key] = value[key];\n                        }\n                        break;\n                    }\n                    default:\n                        context.insert(objectId, index, value, datatype);\n                }\n                index += 1;\n            }\n            return result;\n        },\n        unshift(...values) {\n            this.splice(0, 0, ...values);\n            return context.length(objectId);\n        },\n        entries() {\n            let i = 0;\n            const iterator = {\n                next: () =\u003e {\n                    const value = valueAt(target, i);\n                    if (value === undefined) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        return { value: [i++, value], done: false };\n                    }\n                },\n                [Symbol.iterator]() {\n                    return this;\n                },\n            };\n            return iterator;\n        },\n        keys() {\n            let i = 0;\n            const len = context.length(objectId);\n            const iterator = {\n                next: () =\u003e {\n                    if (i \u003c len) {\n                        return { value: i++, done: false };\n                    }\n                    return { value: undefined, done: true };\n                },\n                [Symbol.iterator]() {\n                    return this;\n                },\n            };\n            return iterator;\n        },\n        values() {\n            let i = 0;\n            const iterator = {\n                next: () =\u003e {\n                    const value = valueAt(target, i++);\n                    if (value === undefined) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        return { value, done: false };\n                    }\n                },\n                [Symbol.iterator]() {\n                    return this;\n                },\n            };\n            return iterator;\n        },\n        toArray() {\n            const list = [];\n            let value;\n            do {\n                value = valueAt(target, list.length);\n                if (value !== undefined) {\n                    list.push(value);\n                }\n            } while (value !== undefined);\n            return list;\n        },\n        map(f) {\n            return this.toArray().map(f);\n        },\n        toString() {\n            return this.toArray().toString();\n        },\n        toLocaleString() {\n            return this.toArray().toLocaleString();\n        },\n        forEach(f) {\n            return this.toArray().forEach(f);\n        },\n        // todo: real concat function is different\n        concat(other) {\n            return this.toArray().concat(other);\n        },\n        every(f) {\n            return this.toArray().every(f);\n        },\n        filter(f) {\n            return this.toArray().filter(f);\n        },\n        find(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return v;\n                }\n                index += 1;\n            }\n        },\n        findIndex(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return index;\n                }\n                index += 1;\n            }\n            return -1;\n        },\n        includes(elem) {\n            return this.find(e =\u003e e === elem) !== undefined;\n        },\n        join(sep) {\n            return this.toArray().join(sep);\n        },\n        reduce(f, initialValue) {\n            return this.toArray().reduce(f, initialValue);\n        },\n        reduceRight(f, initialValue) {\n            return this.toArray().reduceRight(f, initialValue);\n        },\n        lastIndexOf(search, fromIndex = +Infinity) {\n            // this can be faster\n            return this.toArray().lastIndexOf(search, fromIndex);\n        },\n        slice(index, num) {\n            return this.toArray().slice(index, num);\n        },\n        some(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return true;\n                }\n                index += 1;\n            }\n            return false;\n        },\n        [Symbol.iterator]: function* () {\n            let i = 0;\n            let value = valueAt(target, i);\n            while (value !== undefined) {\n                yield value;\n                i += 1;\n                value = valueAt(target, i);\n            }\n        },\n    };\n    return methods;\n}\nfunction textMethods(target) {\n    const { context, objectId } = target;\n    const methods = {\n        set(index, value) {\n            return (this[index] = value);\n        },\n        get(index) {\n            return this[index];\n        },\n        toString() {\n            return context.text(objectId).replace(//g, \"\");\n        },\n        toSpans() {\n            const spans = [];\n            let chars = \"\";\n            const length = context.length(objectId);\n            for (let i = 0; i \u003c length; i++) {\n                const value = this[i];\n                if (typeof value === \"string\") {\n                    chars += value;\n                }\n                else {\n                    if (chars.length \u003e 0) {\n                        spans.push(chars);\n                        chars = \"\";\n                    }\n                    spans.push(value);\n                }\n            }\n            if (chars.length \u003e 0) {\n                spans.push(chars);\n            }\n            return spans;\n        },\n        toJSON() {\n            return this.toString();\n        },\n        indexOf(o, start = 0) {\n            const text = context.text(objectId);\n            return text.indexOf(o, start);\n        },\n        insertAt(index, ...values) {\n            if (values.every(v =\u003e typeof v === \"string\")) {\n                context.splice(objectId, index, 0, values.join(\"\"));\n            }\n            else {\n                listMethods(target).insertAt(index, ...values);\n            }\n        },\n    };\n    return methods;\n}\nfunction assertText(value) {\n    if (!(value instanceof Text)) {\n        throw new Error(\"value was not a Text instance\");\n    }\n}\nfunction assertString(value) {\n    if (typeof value !== \"string\") {\n        throw new Error(\"value was not a string\");\n    }\n}\nfunction printPath(path) {\n    // print the path as a json pointer\n    const jsonPointerComponents = path.map(component =\u003e {\n        // if its a number just turn it into a string\n        if (typeof component === \"number\") {\n            return component.toString();\n        }\n        else if (typeof component === \"string\") {\n            // otherwise we have to escape `/` and `~` characters\n            return component.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n        }\n    });\n    if (path.length === 0) {\n        return \"\";\n    }\n    else {\n        return \"/\" + jsonPointerComponents.join(\"/\");\n    }\n}\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' \u0026\u0026 crypto.getRandomValues \u0026\u0026 crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i \u003c 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' \u0026\u0026 crypto.randomUUID \u0026\u0026 crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID \u0026\u0026 !buf \u0026\u0026 !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] \u0026 0x0f | 0x40;\n  rnds[8] = rnds[8] \u0026 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i \u003c 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","import { v4 } from \"uuid\";\nfunction defaultFactory() {\n    return v4().replace(/-/g, \"\");\n}\nlet factory = defaultFactory;\nexport const uuid = () =\u003e {\n    return factory();\n};\nuuid.setFactory = newFactory =\u003e {\n    factory = newFactory;\n};\nuuid.reset = () =\u003e {\n    factory = defaultFactory;\n};\n","let wasm;\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx \u003c 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () =\u003e { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) \u003e\u003e\u003e 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) \u003e\u003e\u003e 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset \u003c len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code \u003e 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) \u003e\u003e\u003e 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) \u003e\u003e\u003e 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () =\u003e { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr \u003e\u003e\u003e 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' \u0026\u0026 name.length \u003e 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length \u003e 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i \u003c length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length \u003e 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* @param {any} options\n* @returns {Automerge}\n*/\nexport function create(options) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.create(retptr, addHeapObject(options));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return Automerge.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Uint8Array} data\n* @param {any} options\n* @returns {Automerge}\n*/\nexport function load(data, options) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.load(retptr, addHeapObject(data), addHeapObject(options));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return Automerge.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {any} change\n* @returns {Uint8Array}\n*/\nexport function encodeChange(change) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.encodeChange(retptr, addHeapObject(change));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Uint8Array} change\n* @returns {any}\n*/\nexport function decodeChange(change) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.decodeChange(retptr, addHeapObject(change));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @returns {SyncState}\n*/\nexport function initSyncState() {\n    const ret = wasm.initSyncState();\n    return SyncState.__wrap(ret);\n}\n\n/**\n* @param {any} state\n* @returns {SyncState}\n*/\nexport function importSyncState(state) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.importSyncState(retptr, addHeapObject(state));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return SyncState.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {SyncState} state\n* @returns {any}\n*/\nexport function exportSyncState(state) {\n    _assertClass(state, SyncState);\n    const ret = wasm.exportSyncState(state.__wbg_ptr);\n    return takeObject(ret);\n}\n\n/**\n* @param {any} message\n* @returns {Uint8Array}\n*/\nexport function encodeSyncMessage(message) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.encodeSyncMessage(retptr, addHeapObject(message));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Uint8Array} msg\n* @returns {any}\n*/\nexport function decodeSyncMessage(msg) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.decodeSyncMessage(retptr, addHeapObject(msg));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {SyncState} state\n* @returns {Uint8Array}\n*/\nexport function encodeSyncState(state) {\n    _assertClass(state, SyncState);\n    const ret = wasm.encodeSyncState(state.__wbg_ptr);\n    return takeObject(ret);\n}\n\n/**\n* @param {Uint8Array} data\n* @returns {SyncState}\n*/\nexport function decodeSyncState(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.decodeSyncState(retptr, addHeapObject(data));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return SyncState.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n* How text is represented in materialized objects on the JS side\n*/\nexport const TextRepresentation = Object.freeze({\n/**\n* As an array of characters and objects\n*/\nArray:0,\"0\":\"Array\",\n/**\n* As a single JS string\n*/\nString:1,\"1\":\"String\", });\n\nconst AutomergeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () =\u003e {}, unregister: () =\u003e {} }\n    : new FinalizationRegistry(ptr =\u003e wasm.__wbg_automerge_free(ptr \u003e\u003e\u003e 0));\n/**\n*/\nexport class Automerge {\n\n    static __wrap(ptr) {\n        ptr = ptr \u003e\u003e\u003e 0;\n        const obj = Object.create(Automerge.prototype);\n        obj.__wbg_ptr = ptr;\n        AutomergeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AutomergeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_automerge_free(ptr);\n    }\n    /**\n    * @param {string | undefined} actor\n    * @param {TextRepresentation} text_rep\n    * @returns {Automerge}\n    */\n    static new(actor, text_rep) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.automerge_new(retptr, ptr0, len0, text_rep);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Automerge.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} [actor]\n    * @returns {Automerge}\n    */\n    clone(actor) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.automerge_clone(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Automerge.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} actor\n    * @param {any} heads\n    * @returns {Automerge}\n    */\n    fork(actor, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.automerge_fork(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Automerge.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    pendingOps() {\n        const ret = wasm.automerge_pendingOps(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string | undefined} [message]\n    * @param {number | undefined} [time]\n    * @returns {any}\n    */\n    commit(message, time) {\n        var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_commit(this.__wbg_ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Automerge} other\n    * @returns {Array\u003cany\u003e}\n    */\n    merge(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, Automerge);\n            wasm.automerge_merge(retptr, this.__wbg_ptr, other.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    rollback() {\n        const ret = wasm.automerge_rollback(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {any} obj\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {Array\u003cany\u003e}\n    */\n    keys(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_keys(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {string}\n    */\n    text(obj, heads) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_text(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {Array\u003cany\u003e}\n    */\n    spans(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_spans(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} start\n    * @param {number} delete_count\n    * @param {any} text\n    */\n    splice(obj, start, delete_count, text) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_splice(retptr, this.__wbg_ptr, addHeapObject(obj), start, delete_count, addHeapObject(text));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} new_text\n    */\n    updateText(obj, new_text) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_updateText(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(new_text));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} args\n    */\n    updateSpans(obj, args) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_updateSpans(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(args));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} value\n    * @param {any} datatype\n    */\n    push(obj, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_push(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} value\n    * @returns {string | undefined}\n    */\n    pushObject(obj, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_pushObject(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {any} value\n    * @param {any} datatype\n    */\n    insert(obj, index, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_insert(retptr, this.__wbg_ptr, addHeapObject(obj), index, addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {any} args\n    */\n    splitBlock(obj, index, args) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_splitBlock(retptr, this.__wbg_ptr, addHeapObject(obj), index, addHeapObject(args));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} text\n    * @param {number} index\n    */\n    joinBlock(text, index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_joinBlock(retptr, this.__wbg_ptr, addHeapObject(text), index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} text\n    * @param {number} index\n    * @param {any} args\n    */\n    updateBlock(text, index, args) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_updateBlock(retptr, this.__wbg_ptr, addHeapObject(text), index, addHeapObject(args));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} text\n    * @param {number} index\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {any}\n    */\n    getBlock(text, index, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getBlock(retptr, this.__wbg_ptr, addHeapObject(text), index, isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {any} value\n    * @returns {string | undefined}\n    */\n    insertObject(obj, index, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_insertObject(retptr, this.__wbg_ptr, addHeapObject(obj), index, addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {any} value\n    * @param {any} datatype\n    */\n    put(obj, prop, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_put(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {any} value\n    * @returns {any}\n    */\n    putObject(obj, prop, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_putObject(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {any} value\n    */\n    increment(obj, prop, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_increment(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {any}\n    */\n    get(obj, prop, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_get(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {any}\n    */\n    getWithType(obj, prop, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getWithType(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {object}\n    */\n    objInfo(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_objInfo(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} arg\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {Array\u003cany\u003e}\n    */\n    getAll(obj, arg, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getAll(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(arg), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} enable\n    * @returns {any}\n    */\n    enableFreeze(enable) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_enableFreeze(retptr, this.__wbg_ptr, addHeapObject(enable));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} datatype\n    * @param {any} export_function\n    * @param {any} import_function\n    */\n    registerDatatype(datatype, export_function, import_function) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_registerDatatype(retptr, this.__wbg_ptr, addHeapObject(datatype), addHeapObject(export_function), addHeapObject(import_function));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} object\n    * @param {any} meta\n    * @returns {any}\n    */\n    applyPatches(object, meta) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_applyPatches(retptr, this.__wbg_ptr, addHeapObject(object), addHeapObject(meta));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} object\n    * @param {any} meta\n    * @returns {any}\n    */\n    applyAndReturnPatches(object, meta) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_applyAndReturnPatches(retptr, this.__wbg_ptr, addHeapObject(object), addHeapObject(meta));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Array\u003cany\u003e}\n    */\n    diffIncremental() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_diffIncremental(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    */\n    updateDiffCursor() {\n        wasm.automerge_updateDiffCursor(this.__wbg_ptr);\n    }\n    /**\n    */\n    resetDiffCursor() {\n        wasm.automerge_resetDiffCursor(this.__wbg_ptr);\n    }\n    /**\n    * @param {Array\u003cany\u003e} before\n    * @param {Array\u003cany\u003e} after\n    * @returns {Array\u003cany\u003e}\n    */\n    diff(before, after) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_diff(retptr, this.__wbg_ptr, addHeapObject(before), addHeapObject(after));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Array\u003cany\u003e} heads\n    */\n    isolate(heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_isolate(retptr, this.__wbg_ptr, addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    */\n    integrate() {\n        wasm.automerge_integrate(this.__wbg_ptr);\n    }\n    /**\n    * @param {any} obj\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {number}\n    */\n    length(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_length(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getFloat64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    */\n    delete(obj, prop) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_delete(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    save() {\n        const ret = wasm.automerge_save(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    saveIncremental() {\n        const ret = wasm.automerge_saveIncremental(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Array\u003cany\u003e} heads\n    * @returns {Uint8Array}\n    */\n    saveSince(heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_saveSince(retptr, this.__wbg_ptr, addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    saveNoCompress() {\n        const ret = wasm.automerge_saveNoCompress(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    saveAndVerify() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_saveAndVerify(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {number}\n    */\n    loadIncremental(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_loadIncremental(retptr, this.__wbg_ptr, addHeapObject(data));\n            var r0 = getFloat64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} changes\n    */\n    applyChanges(changes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_applyChanges(retptr, this.__wbg_ptr, addHeapObject(changes));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} have_deps\n    * @returns {Array\u003cany\u003e}\n    */\n    getChanges(have_deps) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getChanges(retptr, this.__wbg_ptr, addHeapObject(have_deps));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} hash\n    * @returns {any}\n    */\n    getChangeByHash(hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getChangeByHash(retptr, this.__wbg_ptr, addHeapObject(hash));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} hash\n    * @returns {any}\n    */\n    getDecodedChangeByHash(hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getDecodedChangeByHash(retptr, this.__wbg_ptr, addHeapObject(hash));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Automerge} other\n    * @returns {Array\u003cany\u003e}\n    */\n    getChangesAdded(other) {\n        _assertClass(other, Automerge);\n        const ret = wasm.automerge_getChangesAdded(this.__wbg_ptr, other.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Array\u003cany\u003e}\n    */\n    getHeads() {\n        const ret = wasm.automerge_getHeads(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    getActorId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getActorId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    getLastLocalChange() {\n        const ret = wasm.automerge_getLastLocalChange(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    */\n    dump() {\n        wasm.automerge_dump(this.__wbg_ptr);\n    }\n    /**\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {Array\u003cany\u003e}\n    */\n    getMissingDeps(heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getMissingDeps(retptr, this.__wbg_ptr, isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SyncState} state\n    * @param {Uint8Array} message\n    */\n    receiveSyncMessage(state, message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(state, SyncState);\n            wasm.automerge_receiveSyncMessage(retptr, this.__wbg_ptr, state.__wbg_ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SyncState} state\n    * @returns {any}\n    */\n    generateSyncMessage(state) {\n        _assertClass(state, SyncState);\n        const ret = wasm.automerge_generateSyncMessage(this.__wbg_ptr, state.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {any} meta\n    * @returns {any}\n    */\n    toJS(meta) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_toJS(retptr, this.__wbg_ptr, addHeapObject(meta));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array\u003cany\u003e | undefined} heads\n    * @param {any} meta\n    * @returns {any}\n    */\n    materialize(obj, heads, meta) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_materialize(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads), addHeapObject(meta));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {string}\n    */\n    getCursor(obj, index, heads) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getCursor(retptr, this.__wbg_ptr, addHeapObject(obj), index, isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} cursor\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {number}\n    */\n    getCursorPosition(obj, cursor, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getCursorPosition(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(cursor), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getFloat64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} [message]\n    * @param {number | undefined} [time]\n    * @returns {any}\n    */\n    emptyChange(message, time) {\n        var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_emptyChange(this.__wbg_ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);\n        return takeObject(ret);\n    }\n    /**\n    * @param {any} obj\n    * @param {any} range\n    * @param {any} name\n    * @param {any} value\n    * @param {any} datatype\n    */\n    mark(obj, range, name, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_mark(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(range), addHeapObject(name), addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} range\n    * @param {any} name\n    */\n    unmark(obj, range, name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_unmark(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(range), addHeapObject(name));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {any}\n    */\n    marks(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_marks(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {Array\u003cany\u003e | undefined} [heads]\n    * @returns {object}\n    */\n    marksAt(obj, index, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_marksAt(retptr, this.__wbg_ptr, addHeapObject(obj), index, isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SyncState} state\n    * @returns {any}\n    */\n    hasOurChanges(state) {\n        _assertClass(state, SyncState);\n        const ret = wasm.automerge_hasOurChanges(this.__wbg_ptr, state.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    topoHistoryTraversal() {\n        const ret = wasm.automerge_topoHistoryTraversal(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    stats() {\n        const ret = wasm.automerge_stats(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst SyncStateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () =\u003e {}, unregister: () =\u003e {} }\n    : new FinalizationRegistry(ptr =\u003e wasm.__wbg_syncstate_free(ptr \u003e\u003e\u003e 0));\n/**\n*/\nexport class SyncState {\n\n    static __wrap(ptr) {\n        ptr = ptr \u003e\u003e\u003e 0;\n        const obj = Object.create(SyncState.prototype);\n        obj.__wbg_ptr = ptr;\n        SyncStateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SyncStateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_syncstate_free(ptr);\n    }\n    /**\n    * @returns {any}\n    */\n    get sharedHeads() {\n        const ret = wasm.syncstate_sharedHeads(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    get lastSentHeads() {\n        const ret = wasm.syncstate_lastSentHeads(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {any} heads\n    */\n    set lastSentHeads(heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncstate_set_lastSentHeads(retptr, this.__wbg_ptr, addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} hashes\n    */\n    set sentHashes(hashes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncstate_set_sentHashes(retptr, this.__wbg_ptr, addHeapObject(hashes));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {SyncState}\n    */\n    clone() {\n        const ret = wasm.syncstate_clone(this.__wbg_ptr);\n        return SyncState.__wrap(ret);\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' \u0026\u0026 module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' \u0026\u0026 val !== null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_array = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbindgen_json_serialize = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = JSON.stringify(obj === undefined ? null : obj);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_new_abda76e883ba8a5f = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) == getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg_String_91fba7ded13ba54c = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_20cbc34131e76824 = function(arg0, arg1, arg2) {\n        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_getRandomValues_3aa56aa6edec874c = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_randomFillSync_5c9c955aa56b6049 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).randomFillSync(takeObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_crypto_1d1f22824a6a080c = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_process_4a72847cc503995b = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_f686565e586dd935 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_104a2ff8d6ea03a2 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_cca90b1a94a0255b = function() { return handleError(function () {\n        const ret = module.require;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_msCrypto_eb05e62b530a1508 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_log_5bb5f88f245d7762 = function(arg0) {\n        console.log(getObject(arg0));\n    };\n    imports.wbg.__wbg_log_1746d5c75ec89963 = function(arg0, arg1) {\n        console.log(getObject(arg0), getObject(arg1));\n    };\n    imports.wbg.__wbg_get_bd8e338fbd5f5cc8 = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 \u003e\u003e\u003e 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_cd7af8117672b8b8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_new_16b304a2cfa7ff4a = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newnoargs_e258087cd0daa0ea = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_40fc327bfc8770e6 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_196c84450b364254 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_done_298b57d23c0fc80c = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_value_d93c65011f51a456 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_iterator_2cee6dadfd956dfa = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_e3c254076557e348 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_27c0f87801dedf93 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_72fb9a18b5ae2624 = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_dee433d4c85c9387 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_set_d4638f722068f043 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 \u003e\u003e\u003e 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_from_89e3fc3ba5e6fb48 = function(arg0) {\n        const ret = Array.from(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_isArray_2ab64d95e09ea0ae = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_push_a5b05aedc7234f9f = function(arg0, arg1) {\n        const ret = getObject(arg0).push(getObject(arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_unshift_e22df4b34bcf5070 = function(arg0, arg1) {\n        const ret = getObject(arg0).unshift(getObject(arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_836825be07d4c9d2 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof ArrayBuffer;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_new_28c511d9baebfa89 = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_b3ca7c6051f9bec1 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Date_f65cf97fb83fc369 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Date;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_getTime_2bc4375165f02d15 = function(arg0) {\n        const ret = getObject(arg0).getTime();\n        return ret;\n    };\n    imports.wbg.__wbg_new_cf3ec55744a78578 = function(arg0) {\n        const ret = new Date(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_Object_71ca3c0a59266746 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Object;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_assign_496d2d14fecafbcf = function(arg0, arg1) {\n        const ret = Object.assign(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_defineProperty_cc00e2de8a0f5141 = function(arg0, arg1, arg2) {\n        const ret = Object.defineProperty(getObject(arg0), getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_entries_95cc2c823b285a09 = function(arg0) {\n        const ret = Object.entries(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_freeze_cc6bc19f75299986 = function(arg0) {\n        const ret = Object.freeze(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_keys_91e412b4b222659f = function(arg0) {\n        const ret = Object.keys(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_values_9c75e6e2bfbdb70d = function(arg0) {\n        const ret = Object.values(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_dd6a5dd7b538af21 = function(arg0, arg1) {\n        const ret = new RangeError(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_apply_0a5aa603881e6d79 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.apply(getObject(arg0), getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_deleteProperty_13e721a56f19e842 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.deleteProperty(getObject(arg0), getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_ownKeys_658942b7f28d1fe9 = function() { return handleError(function (arg0) {\n        const ret = Reflect.ownKeys(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_set_1f9b04f170055d33 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_buffer_12d079cc21e14bdb = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_concat_3de229fe4fe90fea = function(arg0, arg1) {\n        const ret = getObject(arg0).concat(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_slice_52fb626ffdc8da8f = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).slice(arg1 \u003e\u003e\u003e 0, arg2 \u003e\u003e\u003e 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_for_27c67e2dbdce22f6 = function(arg0, arg1) {\n        const ret = Symbol.for(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_toString_7df3c77999517c20 = function(arg0) {\n        const ret = getObject(arg0).toString();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_ce0dbfc45cf2f5be = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_c6fb939a7f436783 = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_d1e6af4856ba331b = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_207b558942527489 = function() { return handleError(function () {\n        const ret = global.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 \u003e\u003e\u003e 0, arg2 \u003e\u003e\u003e 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_63b92bc8671ed464 = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_a47bac70306a19a7 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 \u003e\u003e\u003e 0);\n    };\n    imports.wbg.__wbg_length_c20a40f15020d68a = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Uint8Array_2b3bbecd033d19f6 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Uint8Array;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_newwithlength_e9b4878cebadb3d3 = function(arg0) {\n        const ret = new Uint8Array(arg0 \u003e\u003e\u003e 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_subarray_a1f73cd4b5b42fe1 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 \u003e\u003e\u003e 0, arg2 \u003e\u003e\u003e 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedFloat64Memory0 = null;\n    cachedInt32Memory0 = null;\n    cachedUint8Memory0 = null;\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input) {\n    if (wasm !== undefined) return wasm;\n\n    if (typeof input === 'undefined') {\n        input = new URL('automerge_wasm_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' \u0026\u0026 input instanceof Request) || (typeof URL === 'function' \u0026\u0026 input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await input, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync }\nexport default __wbg_init;\n","var __rest = (this \u0026\u0026 this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) \u0026\u0026 e.indexOf(p) \u003c 0)\n        t[p] = s[p];\n    if (s != null \u0026\u0026 typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i \u003c p.length; i++) {\n            if (e.indexOf(p[i]) \u003c 0 \u0026\u0026 Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/** @hidden **/\nexport { /** @hidden */ uuid } from \"./uuid.js\";\nimport { rootProxy } from \"./proxies.js\";\nimport { STATE } from \"./constants.js\";\nimport { Counter, } from \"./types.js\";\nexport { Counter, Int, Uint, Float64, } from \"./types.js\";\nimport { Text } from \"./text.js\";\nexport { Text } from \"./text.js\";\nconst SyncStateSymbol = Symbol(\"_syncstate\");\nimport { ApiHandler, UseApi } from \"./low_level.js\";\nexport { initializeWasm, initializeBase64Wasm, wasmInitialized, isWasmInitialized, } from \"./low_level.js\";\nimport { RawString } from \"./raw_string.js\";\nimport { _state, _is_proxy, _trace, _obj } from \"./internal_state.js\";\nimport { stableConflictAt } from \"./conflicts.js\";\n/**\n * Function for use in {@link change} which inserts values into a list at a given index\n * @param list\n * @param index\n * @param values\n */\nexport function insertAt(list, index, ...values) {\n    if (!_is_proxy(list)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    ;\n    list.insertAt(index, ...values);\n}\n/**\n * Function for use in {@link change} which deletes values from a list at a given index\n * @param list\n * @param index\n * @param numDelete\n */\nexport function deleteAt(list, index, numDelete) {\n    if (!_is_proxy(list)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    ;\n    list.deleteAt(index, numDelete);\n}\n/** @hidden **/\nexport function use(api) {\n    UseApi(api);\n}\n/** @hidden */\nexport function getBackend(doc) {\n    return _state(doc).handle;\n}\nfunction importOpts(_actor) {\n    if (typeof _actor === \"object\") {\n        return _actor;\n    }\n    else {\n        return { actor: _actor };\n    }\n}\n/**\n * Create a new automerge document\n *\n * @typeParam T - The type of value contained in the document. This will be the\n *     type that is passed to the change closure in {@link change}\n * @param _opts - Either an actorId or an {@link InitOptions} (which may\n *     contain an actorId). If this is null the document will be initialised with a\n *     random actor ID\n */\nexport function init(_opts) {\n    const opts = importOpts(_opts);\n    const freeze = !!opts.freeze;\n    const patchCallback = opts.patchCallback;\n    const text_v1 = !(opts.enableTextV2 || false);\n    const actor = opts.actor;\n    const handle = ApiHandler.create({ actor, text_v1 });\n    handle.enableFreeze(!!opts.freeze);\n    const textV2 = opts.enableTextV2 || false;\n    registerDatatypes(handle, textV2);\n    const doc = handle.materialize(\"/\", undefined, {\n        handle,\n        heads: undefined,\n        freeze,\n        patchCallback,\n        textV2,\n    });\n    return doc;\n}\n/**\n * Make an immutable view of an automerge document as at `heads`\n *\n * @remarks\n * The document returned from this function cannot be passed to {@link change}.\n * This is because it shares the same underlying memory as `doc`, but it is\n * consequently a very cheap copy.\n *\n * Note that this function will throw an error if any of the hashes in `heads`\n * are not in the document.\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to create a view of\n * @param heads - The hashes of the heads to create a view at\n */\nexport function view(doc, heads) {\n    const state = _state(doc);\n    const handle = state.handle;\n    return state.handle.materialize(\"/\", heads, Object.assign(Object.assign({}, state), { handle,\n        heads }));\n}\n/**\n * Make a full writable copy of an automerge document\n *\n * @remarks\n * Unlike {@link view} this function makes a full copy of the memory backing\n * the document and can thus be passed to {@link change}. It also generates a\n * new actor ID so that changes made in the new document do not create duplicate\n * sequence numbers with respect to the old document. If you need control over\n * the actor ID which is generated you can pass the actor ID as the second\n * argument\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to clone\n * @param _opts - Either an actor ID to use for the new doc or an {@link InitOptions}\n */\nexport function clone(doc, _opts) {\n    const state = _state(doc);\n    const heads = state.heads;\n    const opts = importOpts(_opts);\n    const handle = state.handle.fork(opts.actor, heads);\n    handle.updateDiffCursor();\n    // `change` uses the presence of state.heads to determine if we are in a view\n    // set it to undefined to indicate that this is a full fat document\n    const { heads: _oldHeads } = state, stateSansHeads = __rest(state, [\"heads\"]);\n    stateSansHeads.patchCallback = opts.patchCallback;\n    return handle.applyPatches(doc, Object.assign(Object.assign({}, stateSansHeads), { handle }));\n}\n/** Explicity free the memory backing a document. Note that this is note\n * necessary in environments which support\n * [`FinalizationRegistry`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry)\n */\nexport function free(doc) {\n    return _state(doc).handle.free();\n}\n/**\n * Create an automerge document from a POJO\n *\n * @param initialState - The initial state which will be copied into the document\n * @typeParam T - The type of the value passed to `from` _and_ the type the resulting document will contain\n * @typeParam actor - The actor ID of the resulting document, if this is null a random actor ID will be used\n *\n * @example\n * ```\n * const doc = automerge.from({\n *     tasks: [\n *         {description: \"feed dogs\", done: false}\n *     ]\n * })\n * ```\n */\nexport function from(initialState, _opts) {\n    return _change(init(_opts), \"from\", {}, d =\u003e Object.assign(d, initialState))\n        .newDoc;\n}\n/**\n * Update the contents of an automerge document\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to update\n * @param options - Either a message, an {@link ChangeOptions}, or a {@link ChangeFn}\n * @param callback - A `ChangeFn` to be used if `options` was a `string`\n *\n * Note that if the second argument is a function it will be used as the `ChangeFn` regardless of what the third argument is.\n *\n * @example A simple change\n * ```\n * let doc1 = automerge.init()\n * doc1 = automerge.change(doc1, d =\u003e {\n *     d.key = \"value\"\n * })\n * assert.equal(doc1.key, \"value\")\n * ```\n *\n * @example A change with a message\n *\n * ```\n * doc1 = automerge.change(doc1, \"add another value\", d =\u003e {\n *     d.key2 = \"value2\"\n * })\n * ```\n *\n * @example A change with a message and a timestamp\n *\n * ```\n * doc1 = automerge.change(doc1, {message: \"add another value\", time: 1640995200}, d =\u003e {\n *     d.key2 = \"value2\"\n * })\n * ```\n *\n * @example responding to a patch callback\n * ```\n * let patchedPath\n * let patchCallback = patch =\u003e {\n *    patchedPath = patch.path\n * }\n * doc1 = automerge.change(doc1, {message: \"add another value\", time: 1640995200, patchCallback}, d =\u003e {\n *     d.key2 = \"value2\"\n * })\n * assert.equal(patchedPath, [\"key2\"])\n * ```\n */\nexport function change(doc, options, callback) {\n    if (typeof options === \"function\") {\n        return _change(doc, \"change\", {}, options).newDoc;\n    }\n    else if (typeof callback === \"function\") {\n        if (typeof options === \"string\") {\n            options = { message: options };\n        }\n        return _change(doc, \"change\", options, callback).newDoc;\n    }\n    else {\n        throw RangeError(\"Invalid args for change\");\n    }\n}\n/**\n * Make a change to the document as it was at a particular point in history\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to update\n * @param scope - The heads representing the point in history to make the change\n * @param options - Either a message or a {@link ChangeOptions} for the new change\n * @param callback - A `ChangeFn` to be used if `options` was a `string`\n *\n * @remarks\n * This function is similar to {@link change} but allows you to make changes to\n * the document as if it were at a particular point in time. To understand this\n * imagine a document created with the following history:\n *\n * ```ts\n * let doc = automerge.from({..})\n * doc = automerge.change(doc, () =\u003e {...})\n *\n * const heads = automerge.getHeads(doc)\n *\n * // fork the document make a change\n * let fork = automerge.fork(doc)\n * fork = automerge.change(fork, () =\u003e {...})\n * const headsOnFork = automerge.getHeads(fork)\n *\n * // make a change on the original doc\n * doc = automerge.change(doc, () =\u003e {...})\n * const headsOnOriginal = automerge.getHeads(doc)\n *\n * // now merge the changes back to the original document\n * doc = automerge.merge(doc, fork)\n *\n * // The heads of the document will now be (headsOnFork, headsOnOriginal)\n * ```\n *\n * {@link ChangeAt} produces an equivalent history, but without having to\n * create a fork of the document. In particular the `newHeads` field of the\n * returned {@link ChangeAtResult} will be the same as `headsOnFork`.\n *\n * Why would you want this? It's typically used in conjunction with {@link diff}\n * to reconcile state which is managed concurrently with the document. For\n * example, if you have a text editor component which the user is modifying\n * and you can't send the changes to the document synchronously you might follow\n * a workflow like this:\n *\n * * On initialization save the current heads of the document in the text editor state\n * * Every time the user makes a change record the change in the text editor state\n *\n * Now from time to time reconcile the editor state and the document\n * * Load the last saved heads from the text editor state, call them `oldHeads`\n * * Apply all the unreconciled changes to the document using `changeAt(doc, oldHeads, ...)`\n * * Get the diff from the resulting document to the current document using {@link diff}\n *   passing the {@link ChangeAtResult.newHeads} as the `before` argument and the\n *   heads of the entire document as the `after` argument.\n * * Apply the diff to the text editor state\n * * Save the current heads of the document in the text editor state\n */\nexport function changeAt(doc, scope, options, callback) {\n    if (typeof options === \"function\") {\n        return _change(doc, \"changeAt\", {}, options, scope);\n    }\n    else if (typeof callback === \"function\") {\n        if (typeof options === \"string\") {\n            options = { message: options };\n        }\n        return _change(doc, \"changeAt\", options, callback, scope);\n    }\n    else {\n        throw RangeError(\"Invalid args for changeAt\");\n    }\n}\nfunction progressDocument(doc, source, heads, callback) {\n    if (heads == null) {\n        return doc;\n    }\n    const state = _state(doc);\n    const nextState = Object.assign(Object.assign({}, state), { heads: undefined });\n    const { value: nextDoc, patches } = state.handle.applyAndReturnPatches(doc, nextState);\n    if (patches.length \u003e 0) {\n        if (callback != null) {\n            callback(patches, { before: doc, after: nextDoc, source });\n        }\n        const newState = _state(nextDoc);\n        newState.mostRecentPatch = {\n            before: _state(doc).heads,\n            after: newState.handle.getHeads(),\n            patches,\n        };\n    }\n    state.heads = heads;\n    return nextDoc;\n}\nfunction _change(doc, source, options, callback, scope) {\n    if (typeof callback !== \"function\") {\n        throw new RangeError(\"invalid change function\");\n    }\n    const state = _state(doc);\n    if (doc === undefined || state === undefined) {\n        throw new RangeError(\"must be the document root\");\n    }\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    let heads = state.handle.getHeads();\n    if (scope \u0026\u0026 headsEqual(scope, heads)) {\n        scope = undefined;\n    }\n    if (scope) {\n        state.handle.isolate(scope);\n        heads = scope;\n    }\n    if (!(\"time\" in options)) {\n        options.time = Math.floor(Date.now() / 1000);\n    }\n    try {\n        state.heads = heads;\n        const root = rootProxy(state.handle, state.textV2);\n        callback(root);\n        if (state.handle.pendingOps() === 0) {\n            state.heads = undefined;\n            if (scope) {\n                state.handle.integrate();\n            }\n            return {\n                newDoc: doc,\n                newHeads: null,\n            };\n        }\n        else {\n            const newHead = state.handle.commit(options.message, options.time);\n            state.handle.integrate();\n            return {\n                newDoc: progressDocument(doc, source, heads, options.patchCallback || state.patchCallback),\n                newHeads: newHead != null ? [newHead] : null,\n            };\n        }\n    }\n    catch (e) {\n        state.heads = undefined;\n        state.handle.rollback();\n        throw e;\n    }\n}\n/**\n * Make a change to a document which does not modify the document\n *\n * @param doc - The doc to add the empty change to\n * @param options - Either a message or a {@link ChangeOptions} for the new change\n *\n * Why would you want to do this? One reason might be that you have merged\n * changes from some other peers and you want to generate a change which\n * depends on those merged changes so that you can sign the new change with all\n * of the merged changes as part of the new change.\n */\nexport function emptyChange(doc, options) {\n    if (options === undefined) {\n        options = {};\n    }\n    if (typeof options === \"string\") {\n        options = { message: options };\n    }\n    if (!(\"time\" in options)) {\n        options.time = Math.floor(Date.now() / 1000);\n    }\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.emptyChange(options.message, options.time);\n    return progressDocument(doc, \"emptyChange\", heads);\n}\n/**\n * Load an automerge document from a compressed document produce by {@link save}\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n * @param data  - The compressed document\n * @param _opts - Either an actor ID or some {@link InitOptions}, if the actor\n *                ID is null a random actor ID will be created\n *\n * Note that `load` will throw an error if passed incomplete content (for\n * example if you are receiving content over the network and don't know if you\n * have the complete document yet). If you need to handle incomplete content use\n * {@link init} followed by {@link loadIncremental}.\n */\nexport function load(data, _opts) {\n    const opts = importOpts(_opts);\n    const actor = opts.actor;\n    const patchCallback = opts.patchCallback;\n    const text_v1 = !(opts.enableTextV2 || false);\n    const unchecked = opts.unchecked || false;\n    const allowMissingDeps = opts.allowMissingChanges || false;\n    const convertRawStringsToText = opts.convertRawStringsToText || false;\n    const handle = ApiHandler.load(data, {\n        text_v1,\n        actor,\n        unchecked,\n        allowMissingDeps,\n        convertRawStringsToText,\n    });\n    handle.enableFreeze(!!opts.freeze);\n    const textV2 = opts.enableTextV2 || false;\n    registerDatatypes(handle, textV2);\n    const doc = handle.materialize(\"/\", undefined, {\n        handle,\n        heads: undefined,\n        patchCallback,\n        textV2,\n    });\n    return doc;\n}\n/**\n * Load changes produced by {@link saveIncremental}, or partial changes\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n * @param data  - The compressedchanges\n * @param opts  - an {@link ApplyOptions}\n *\n * This function is useful when staying up to date with a connected peer.\n * Perhaps the other end sent you a full compresed document which you loaded\n * with {@link load} and they're sending you the result of\n * {@link getLastLocalChange} every time they make a change.\n *\n * Note that this function will succesfully load the results of {@link save} as\n * well as {@link getLastLocalChange} or any other incremental change.\n */\nexport function loadIncremental(doc, data, opts) {\n    if (!opts) {\n        opts = {};\n    }\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + _trace(doc));\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.loadIncremental(data);\n    return progressDocument(doc, \"loadIncremental\", heads, opts.patchCallback || state.patchCallback);\n}\n/**\n * Create binary save data to be appended to a save file or fed into {@link loadIncremental}\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n *\n * This function is useful for incrementally saving state.  The data can be appended to a\n * automerge save file, or passed to a document replicating its state.\n *\n */\nexport function saveIncremental(doc) {\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + _trace(doc));\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    return state.handle.saveIncremental();\n}\n/**\n * Export the contents of a document to a compressed format\n *\n * @param doc - The doc to save\n *\n * The returned bytes can be passed to {@link load} or {@link loadIncremental}\n */\nexport function save(doc) {\n    return _state(doc).handle.save();\n}\n/**\n * Merge `remote` into `local`\n * @typeParam T - The type of values contained in each document\n * @param local - The document to merge changes into\n * @param remote - The document to merge changes from\n *\n * @returns - The merged document\n *\n * Often when you are merging documents you will also need to clone them. Both\n * arguments to `merge` are frozen after the call so you can no longer call\n * mutating methods (such as {@link change}) on them. The symtom of this will be\n * an error which says \"Attempting to change an out of date document\". To\n * overcome this call {@link clone} on the argument before passing it to {@link\n * merge}.\n */\nexport function merge(local, remote) {\n    const localState = _state(local);\n    if (localState.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + _trace(local));\n    }\n    const heads = localState.handle.getHeads();\n    const remoteState = _state(remote);\n    const changes = localState.handle.getChangesAdded(remoteState.handle);\n    localState.handle.applyChanges(changes);\n    return progressDocument(local, \"merge\", heads, localState.patchCallback);\n}\n/**\n * Get the actor ID associated with the document\n */\nexport function getActorId(doc) {\n    const state = _state(doc);\n    return state.handle.getActorId();\n}\n/**\n * Get the conflicts associated with a property\n *\n * The values of properties in a map in automerge can be conflicted if there\n * are concurrent \"put\" operations to the same key. Automerge chooses one value\n * arbitrarily (but deterministically, any two nodes who have the same set of\n * changes will choose the same value) from the set of conflicting values to\n * present as the value of the key.\n *\n * Sometimes you may want to examine these conflicts, in this case you can use\n * {@link getConflicts} to get the conflicts for the key.\n *\n * @example\n * ```\n * import * as automerge from \"@automerge/automerge\"\n *\n * type Profile = {\n *     pets: Array\u003c{name: string, type: string}\u003e\n * }\n *\n * let doc1 = automerge.init\u003cProfile\u003e(\"aaaa\")\n * doc1 = automerge.change(doc1, d =\u003e {\n *     d.pets = [{name: \"Lassie\", type: \"dog\"}]\n * })\n * let doc2 = automerge.init\u003cProfile\u003e(\"bbbb\")\n * doc2 = automerge.merge(doc2, automerge.clone(doc1))\n *\n * doc2 = automerge.change(doc2, d =\u003e {\n *     d.pets[0].name = \"Beethoven\"\n * })\n *\n * doc1 = automerge.change(doc1, d =\u003e {\n *     d.pets[0].name = \"Babe\"\n * })\n *\n * const doc3 = automerge.merge(doc1, doc2)\n *\n * // Note that here we pass `doc3.pets`, not `doc3`\n * let conflicts = automerge.getConflicts(doc3.pets[0], \"name\")\n *\n * // The two conflicting values are the keys of the conflicts object\n * assert.deepEqual(Object.values(conflicts), [\"Babe\", Beethoven\"])\n * ```\n */\nexport function getConflicts(doc, prop) {\n    const state = _state(doc, false);\n    if (state.textV2) {\n        throw new Error(\"use unstable.getConflicts for an unstable document\");\n    }\n    const objectId = _obj(doc);\n    if (objectId != null) {\n        return stableConflictAt(state.handle, objectId, prop);\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Get the binary representation of the last change which was made to this doc\n *\n * This is most useful when staying in sync with other peers, every time you\n * make a change locally via {@link change} you immediately call {@link\n * getLastLocalChange} and send the result over the network to other peers.\n */\nexport function getLastLocalChange(doc) {\n    const state = _state(doc);\n    return state.handle.getLastLocalChange() || undefined;\n}\n/**\n * Return the object ID of an arbitrary javascript value\n *\n * This is useful to determine if something is actually an automerge document,\n * if `doc` is not an automerge document this will return null.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getObjectId(doc, prop) {\n    if (prop) {\n        const state = _state(doc, false);\n        const objectId = _obj(doc);\n        if (!state || !objectId) {\n            return null;\n        }\n        return state.handle.get(objectId, prop);\n    }\n    else {\n        return _obj(doc);\n    }\n}\n/**\n * Get the changes which are in `newState` but not in `oldState`. The returned\n * changes can be loaded in `oldState` via {@link applyChanges}.\n *\n * Note that this will crash if there are changes in `oldState` which are not in `newState`.\n */\nexport function getChanges(oldState, newState) {\n    const n = _state(newState);\n    return n.handle.getChanges(getHeads(oldState));\n}\n/**\n * Get all the changes in a document\n *\n * This is different to {@link save} because the output is an array of changes\n * which can be individually applied via {@link applyChanges}`\n *\n */\nexport function getAllChanges(doc) {\n    const state = _state(doc);\n    return state.handle.getChanges([]);\n}\n/**\n * Apply changes received from another document\n *\n * `doc` will be updated to reflect the `changes`. If there are changes which\n * we do not have dependencies for yet those will be stored in the document and\n * applied when the depended on changes arrive.\n *\n * You can use the {@link ApplyOptions} to pass a patchcallback which will be\n * informed of any changes which occur as a result of applying the changes\n *\n */\nexport function applyChanges(doc, changes, opts) {\n    const state = _state(doc);\n    if (!opts) {\n        opts = {};\n    }\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.applyChanges(changes);\n    state.heads = heads;\n    return [\n        progressDocument(doc, \"applyChanges\", heads, opts.patchCallback || state.patchCallback),\n    ];\n}\n/** @hidden */\nexport function getHistory(doc) {\n    const textV2 = _state(doc).textV2;\n    const history = getAllChanges(doc);\n    return history.map((change, index) =\u003e ({\n        get change() {\n            return decodeChange(change);\n        },\n        get snapshot() {\n            const [state] = applyChanges(init({ enableTextV2: textV2 }), history.slice(0, index + 1));\n            return state;\n        },\n    }));\n}\n/**\n * Create a set of patches representing the change from one set of heads to another\n *\n * If either of the heads are missing from the document the returned set of patches will be empty\n */\nexport function diff(doc, before, after) {\n    checkHeads(before, \"before\");\n    checkHeads(after, \"after\");\n    const state = _state(doc);\n    if (state.mostRecentPatch \u0026\u0026\n        equals(state.mostRecentPatch.before, before) \u0026\u0026\n        equals(state.mostRecentPatch.after, after)) {\n        return state.mostRecentPatch.patches;\n    }\n    return state.handle.diff(before, after);\n}\nfunction headsEqual(heads1, heads2) {\n    if (heads1.length !== heads2.length) {\n        return false;\n    }\n    for (let i = 0; i \u003c heads1.length; i++) {\n        if (heads1[i] !== heads2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction checkHeads(heads, fieldname) {\n    if (!Array.isArray(heads)) {\n        throw new Error(`${fieldname} must be an array`);\n    }\n}\n/** @hidden */\n// FIXME : no tests\n// FIXME can we just use deep equals now?\nexport function equals(val1, val2) {\n    if (!isObject(val1) || !isObject(val2))\n        return val1 === val2;\n    const keys1 = Object.keys(val1).sort(), keys2 = Object.keys(val2).sort();\n    if (keys1.length !== keys2.length)\n        return false;\n    for (let i = 0; i \u003c keys1.length; i++) {\n        if (keys1[i] !== keys2[i])\n            return false;\n        if (!equals(val1[keys1[i]], val2[keys2[i]]))\n            return false;\n    }\n    return true;\n}\n/**\n * encode a {@link SyncState} into binary to send over the network\n *\n * @group sync\n * */\nexport function encodeSyncState(state) {\n    const sync = ApiHandler.importSyncState(state);\n    const result = ApiHandler.encodeSyncState(sync);\n    sync.free();\n    return result;\n}\n/**\n * Decode some binary data into a {@link SyncState}\n *\n * @group sync\n */\nexport function decodeSyncState(state) {\n    const sync = ApiHandler.decodeSyncState(state);\n    const result = ApiHandler.exportSyncState(sync);\n    sync.free();\n    return result;\n}\n/**\n * Generate a sync message to send to the peer represented by `inState`\n * @param doc - The doc to generate messages about\n * @param inState - The {@link SyncState} representing the peer we are talking to\n *\n * @group sync\n *\n * @returns An array of `[newSyncState, syncMessage | null]` where\n * `newSyncState` should replace `inState` and `syncMessage` should be sent to\n * the peer if it is not null. If `syncMessage` is null then we are up to date.\n */\nexport function generateSyncMessage(doc, inState) {\n    const state = _state(doc);\n    const syncState = ApiHandler.importSyncState(inState);\n    const message = state.handle.generateSyncMessage(syncState);\n    const outState = ApiHandler.exportSyncState(syncState);\n    return [outState, message];\n}\n/**\n * Update a document and our sync state on receiving a sync message\n *\n * @group sync\n *\n * @param doc     - The doc the sync message is about\n * @param inState - The {@link SyncState} for the peer we are communicating with\n * @param message - The message which was received\n * @param opts    - Any {@link ApplyOption}s, used for passing a\n *                  {@link PatchCallback} which will be informed of any changes\n *                  in `doc` which occur because of the received sync message.\n *\n * @returns An array of `[newDoc, newSyncState, syncMessage | null]` where\n * `newDoc` is the updated state of `doc`, `newSyncState` should replace\n * `inState` and `syncMessage` should be sent to the peer if it is not null. If\n * `syncMessage` is null then we are up to date.\n */\nexport function receiveSyncMessage(doc, inState, message, opts) {\n    const syncState = ApiHandler.importSyncState(inState);\n    if (!opts) {\n        opts = {};\n    }\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.receiveSyncMessage(syncState, message);\n    const outSyncState = ApiHandler.exportSyncState(syncState);\n    return [\n        progressDocument(doc, \"receiveSyncMessage\", heads, opts.patchCallback || state.patchCallback),\n        outSyncState,\n        null,\n    ];\n}\n/**\n * Check whether the replica represented by `remoteState` has all our changes\n *\n * @param doc - The doc to check whether the remote has changes for\n * @param remoteState - The {@link SyncState} representing the peer we are talking to\n *\n * @group sync\n *\n * @returns true if the remote has all of our changes\n */\nexport function hasOurChanges(doc, remoteState) {\n    const state = _state(doc);\n    const syncState = ApiHandler.importSyncState(remoteState);\n    return state.handle.hasOurChanges(syncState);\n}\n/**\n * Create a new, blank {@link SyncState}\n *\n * When communicating with a peer for the first time use this to generate a new\n * {@link SyncState} for them\n *\n * @group sync\n */\nexport function initSyncState() {\n    return ApiHandler.exportSyncState(ApiHandler.initSyncState());\n}\n/** @hidden */\nexport function encodeChange(change) {\n    return ApiHandler.encodeChange(change);\n}\n/** @hidden */\nexport function decodeChange(data) {\n    return ApiHandler.decodeChange(data);\n}\n/** @hidden */\nexport function encodeSyncMessage(message) {\n    return ApiHandler.encodeSyncMessage(message);\n}\n/** @hidden */\nexport function decodeSyncMessage(message) {\n    return ApiHandler.decodeSyncMessage(message);\n}\n/**\n * Get any changes in `doc` which are not dependencies of `heads`\n */\nexport function getMissingDeps(doc, heads) {\n    const state = _state(doc);\n    return state.handle.getMissingDeps(heads);\n}\n/**\n * Get the hashes of the heads of this document\n */\nexport function getHeads(doc) {\n    const state = _state(doc);\n    return state.heads || state.handle.getHeads();\n}\n/** @hidden */\nexport function dump(doc) {\n    const state = _state(doc);\n    state.handle.dump();\n}\n/** @hidden */\nexport function toJS(doc) {\n    const state = _state(doc);\n    const enabled = state.handle.enableFreeze(false);\n    const result = state.handle.materialize();\n    state.handle.enableFreeze(enabled);\n    return result;\n}\nexport function isAutomerge(doc) {\n    if (typeof doc == \"object\" \u0026\u0026 doc !== null) {\n        return getObjectId(doc) === \"_root\" \u0026\u0026 !!Reflect.get(doc, STATE);\n    }\n    else {\n        return false;\n    }\n}\nfunction isObject(obj) {\n    return typeof obj === \"object\" \u0026\u0026 obj !== null;\n}\nexport function saveSince(doc, heads) {\n    const state = _state(doc);\n    const result = state.handle.saveSince(heads);\n    return result;\n}\n/**\n * Returns true if the document has all of the given heads somewhere in its history\n */\nexport function hasHeads(doc, heads) {\n    const state = _state(doc);\n    for (const hash of heads) {\n        if (!state.handle.getChangeByHash(hash)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction registerDatatypes(handle, textV2) {\n    handle.registerDatatype(\"counter\", (n) =\u003e new Counter(n), n =\u003e {\n        if (n instanceof Counter) {\n            return n.value;\n        }\n    });\n    if (textV2) {\n        handle.registerDatatype(\"str\", (n) =\u003e {\n            return new RawString(n);\n        }, s =\u003e {\n            if (s instanceof RawString) {\n                return s.val;\n            }\n        });\n    }\n    else {\n        handle.registerDatatype(\"text\", (n) =\u003e new Text(n), t =\u003e {\n            if (t instanceof Text) {\n                return t.join(\"\");\n            }\n        });\n    }\n}\n/**\n * @hidden\n */\nexport function topoHistoryTraversal(doc) {\n    const state = _state(doc);\n    return state.handle.topoHistoryTraversal();\n}\n/**\n * Decode a change hash into the details of this change\n *\n * This should be considered a semi-stable API. We try not to change the\n * encoding in backwards incompatible ways but we won't bump a major version if\n * we do have to change it\n */\nexport function inspectChange(doc, changeHash) {\n    const state = _state(doc);\n    return state.handle.getDecodedChangeByHash(changeHash);\n}\n/**\n * Return some internal statistics about the document\n */\nexport function stats(doc) {\n    const state = _state(doc);\n    return state.handle.stats();\n}\n","import * as A from \"@automerge/automerge/slim/next\";\nimport debug from \"debug\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { assertEvent, assign, createActor, setup, waitFor } from \"xstate\";\nimport { stringifyAutomergeUrl } from \"./AutomergeUrl.js\";\nimport { encode } from \"./helpers/cbor.js\";\nimport { headsAreSame } from \"./helpers/headsAreSame.js\";\nimport { withTimeout } from \"./helpers/withTimeout.js\";\n/**\n * A DocHandle is a wrapper around a single Automerge document that lets us listen for changes and\n * notify the network and storage of new changes.\n *\n * @remarks\n * A `DocHandle` represents a document which is being managed by a {@link Repo}. You shouldn't ever\n * instantiate this yourself. To obtain `DocHandle` use {@link Repo.find} or {@link Repo.create}.\n *\n * To modify the underlying document use either {@link DocHandle.change} or\n * {@link DocHandle.changeAt}. These methods will notify the `Repo` that some change has occured and\n * the `Repo` will save any new changes to the attached {@link StorageAdapter} and send sync\n * messages to connected peers.\n */\nexport class DocHandle extends EventEmitter {\n    documentId;\n    #log;\n    /** The XState actor running our state machine.  */\n    #machine;\n    /** The last known state of our document. */\n    #prevDocState = A.init();\n    /** How long to wait before giving up on a document. (Note that a document will be marked\n     * unavailable much sooner if all known peers respond that they don't have it.) */\n    #timeoutDelay = 60_000;\n    /** A dictionary mapping each peer to the last heads we know they have. */\n    #remoteHeads = {};\n    /** @hidden */\n    constructor(documentId, options = {}) {\n        super();\n        this.documentId = documentId;\n        if (\"timeoutDelay\" in options \u0026\u0026 options.timeoutDelay) {\n            this.#timeoutDelay = options.timeoutDelay;\n        }\n        const doc = A.init();\n        this.#log = debug(`automerge-repo:dochandle:${this.documentId.slice(0, 5)}`);\n        const delay = this.#timeoutDelay;\n        const machine = setup({\n            types: {\n                context: {},\n                events: {},\n            },\n            actions: {\n                /** Update the doc using the given callback and put the modified doc in context */\n                onUpdate: assign(({ context, event }) =\u003e {\n                    const oldDoc = context.doc;\n                    assertEvent(event, UPDATE);\n                    const { callback } = event.payload;\n                    const doc = callback(oldDoc);\n                    return { doc };\n                }),\n                onDelete: assign(() =\u003e {\n                    this.emit(\"delete\", { handle: this });\n                    return { doc: A.init() };\n                }),\n                onUnavailable: () =\u003e {\n                    this.emit(\"unavailable\", { handle: this });\n                },\n            },\n        }).createMachine({\n            /** @xstate-layout N4IgpgJg5mDOIC5QAoC2BDAxgCwJYDswBKAYgFUAFAEQEEAVAUQG0AGAXUVAAcB7WXAC64e+TiAAeiAOwAOAKwA6ACxSAzKqks1ATjlTdAGhABPRAFolAJksKN2y1KtKAbFLla5AX09G0WPISkVAwAMgyMrBxIILz8QiJikggAjCzOijKqLEqqybJyLizaRqYIFpbJtro5Uo7J2o5S3r4YOATECrgQADZgJADCAEoM9MzsYrGCwqLRSeoyCtra8pa5adquySXmDjY5ac7JljLJeepKzSB+bYGdPX0AYgCSAHJUkRN8UwmziM7HCgqyVcUnqcmScmcMm2ZV2yiyzkOx1OalUFx8V1aAQ63R46AgBCgJGGAEUyAwAMp0D7RSbxGagJKHFgKOSWJTJGRSCosCpKaEmRCqbQKU5yXINeTaer6LwY67YogKXH4wkkKgAeX6AH1hjQqABNGncL70xKIJQ5RY5BHOJag6wwpRyEWImQVeT1aWrVSXBXtJUqgn4Ik0ADqNCedG1L3CYY1gwA0saYqbpuaEG4pKLksKpFDgcsCjDhTnxTKpTLdH6sQGFOgAO7oKYhl5gAQNngAJwA1iRY3R40ndSNDSm6enfpm5BkWAVkvy7bpuTCKq7ndZnfVeSwuTX-HWu2AAI4AVzgQhD6q12rILxoADVIyEaAAhMLjtM-RmIE4LVSQi4nLLDIGzOCWwLKA0cgyLBoFWNy+43B0R5nheaqajqepjuMtJfgyEh-FoixqMCoKqOyhzgYKCDOq6UIeuCSxHOoSGKgop74OgABuzbdOgABGvTXlho5GrhJpxJOP4pLulT6KoMhpJY2hzsWNF0QobqMV6LG+pc+A8BAcBiP6gSfFJ36EQgKksksKxrHamwwmY7gLKB85QjBzoAWxdZdL0FnfARST8ooLC7qoTnWBU4pyC5ViVMKBQaHUDQuM4fm3EGhJBWaU7-CysEAUp3LpEpWw0WYRw2LmqzgqciIsCxWUdI2zaXlAbYdt2PZ5dJ1n5jY2iJY1ikOIcMJHCyUWHC62hRZkUVNPKta3Kh56wJ1-VWUyzhFc64JWJCtQNBBzhQW4cHwbsrVKpxPF8YJgV4ZZIWIKkiKiiNSkqZYWjzCWaQ5hFh0AcCuR3QoR74qUknBRmzholpv3OkpRQNNRpTzaKTWKbIWR5FDxm9AIkA7e9skUYCWayLILBZGoLkUSKbIyIdpxHPoyTeN4QA */\n            // You can use the XState extension for VS Code to visualize this machine.\n            // Or, you can see this static visualization (last updated April 2024): https://stately.ai/registry/editor/d7af9b58-c518-44f1-9c36-92a238b04a7a?machineId=91c387e7-0f01-42c9-a21d-293e9bf95bb7\n            initial: \"idle\",\n            context: { documentId, doc },\n            on: {\n                UPDATE: { actions: \"onUpdate\" },\n                DELETE: \".deleted\",\n            },\n            states: {\n                idle: {\n                    on: {\n                        BEGIN: \"loading\",\n                    },\n                },\n                loading: {\n                    on: {\n                        REQUEST: \"requesting\",\n                        DOC_READY: \"ready\",\n                    },\n                    after: { [delay]: \"unavailable\" },\n                },\n                requesting: {\n                    on: {\n                        DOC_UNAVAILABLE: \"unavailable\",\n                        DOC_READY: \"ready\",\n                    },\n                    after: { [delay]: \"unavailable\" },\n                },\n                unavailable: {\n                    entry: \"onUnavailable\",\n                    on: { DOC_READY: \"ready\" },\n                },\n                ready: {},\n                deleted: { entry: \"onDelete\", type: \"final\" },\n            },\n        });\n        // Instantiate the state machine\n        this.#machine = createActor(machine);\n        // Listen for state transitions\n        this.#machine.subscribe(state =\u003e {\n            const before = this.#prevDocState;\n            const after = state.context.doc;\n            this.#log(` ${state.value} %o`, after);\n            // if the document has changed, emit a change event\n            this.#checkForChanges(before, after);\n        });\n        // Start the machine, and send a create or find event to get things going\n        this.#machine.start();\n        this.#machine.send({ type: BEGIN });\n    }\n    // PRIVATE\n    /** Returns the current document, regardless of state */\n    get #doc() {\n        return this.#machine?.getSnapshot().context.doc;\n    }\n    /** Returns the docHandle's state (READY, etc.) */\n    get #state() {\n        return this.#machine?.getSnapshot().value;\n    }\n    /** Returns a promise that resolves when the docHandle is in one of the given states */\n    #statePromise(awaitStates) {\n        const awaitStatesArray = Array.isArray(awaitStates)\n            ? awaitStates\n            : [awaitStates];\n        return waitFor(this.#machine, s =\u003e awaitStatesArray.some(state =\u003e s.matches(state)), \n        // use a longer delay here so as not to race with other delays\n        { timeout: this.#timeoutDelay * 2 });\n    }\n    /**\n     * Called after state transitions. If the document has changed, emits a change event. If we just\n     * received the document for the first time, signal that our request has been completed.\n     */\n    #checkForChanges(before, after) {\n        const beforeHeads = A.getHeads(before);\n        const afterHeads = A.getHeads(after);\n        const docChanged = !headsAreSame(afterHeads, beforeHeads);\n        if (docChanged) {\n            this.emit(\"heads-changed\", { handle: this, doc: after });\n            const patches = A.diff(after, beforeHeads, afterHeads);\n            if (patches.length \u003e 0) {\n                this.emit(\"change\", {\n                    handle: this,\n                    doc: after,\n                    patches,\n                    // TODO: pass along the source (load/change/network)\n                    patchInfo: { before, after, source: \"change\" },\n                });\n            }\n            // If we didn't have the document yet, signal that we now do\n            if (!this.isReady())\n                this.#machine.send({ type: DOC_READY });\n        }\n        this.#prevDocState = after;\n    }\n    // PUBLIC\n    /** Our documentId in Automerge URL form.\n     */\n    get url() {\n        return stringifyAutomergeUrl({ documentId: this.documentId });\n    }\n    /**\n     * @returns true if the document is ready for accessing or changes.\n     *\n     * Note that for documents already stored locally this occurs before synchronization with any\n     * peers. We do not currently have an equivalent `whenSynced()`.\n     */\n    isReady = () =\u003e this.inState([\"ready\"]);\n    /**\n     * @returns true if the document has been marked as deleted.\n     *\n     * Deleted documents are removed from local storage and the sync process. It's not currently\n     * possible at runtime to undelete a document.\n     */\n    isDeleted = () =\u003e this.inState([\"deleted\"]);\n    /**\n     * @returns true if the document is currently unavailable.\n     *\n     * This will be the case if the document is not found in storage and no peers have shared it with us.\n     */\n    isUnavailable = () =\u003e this.inState([\"unavailable\"]);\n    /**\n     * @returns true if the handle is in one of the given states.\n     */\n    inState = (states) =\u003e states.some(s =\u003e this.#machine.getSnapshot().matches(s));\n    /** @hidden */\n    get state() {\n        return this.#machine.getSnapshot().value;\n    }\n    /**\n     * @returns a promise that resolves when the document is in one of the given states (if no states\n     * are passed, when the document is ready)\n     *\n     * Use this to block until the document handle has finished loading. The async equivalent to\n     * checking `inState()`.\n     */\n    async whenReady(awaitStates = [\"ready\"]) {\n        await withTimeout(this.#statePromise(awaitStates), this.#timeoutDelay);\n    }\n    /**\n     * @returns the current state of this handle's Automerge document.\n     *\n     * This is the recommended way to access a handle's document. Note that this waits for the handle\n     * to be ready if necessary. If loading (or synchronization) fails, this will never resolve.\n     */\n    async doc(\n    /** states to wait for, such as \"LOADING\". mostly for internal use. */\n    awaitStates = [\"ready\", \"unavailable\"]) {\n        try {\n            // wait for the document to enter one of the desired states\n            await this.#statePromise(awaitStates);\n        }\n        catch (error) {\n            // if we timed out, return undefined\n            return undefined;\n        }\n        // Return the document\n        return !this.isUnavailable() ? this.#doc : undefined;\n    }\n    /**\n     * Synchronously returns the current state of the Automerge document this handle manages, or\n     * undefined. Consider using `await handle.doc()` instead. Check `isReady()`, or use `whenReady()`\n     * if you want to make sure loading is complete first.\n     *\n     * Not to be confused with the SyncState of the document, which describes the state of the\n     * synchronization process.\n     *\n     * Note that `undefined` is not a valid Automerge document, so the return from this function is\n     * unambigous.\n     *\n     * @returns the current document, or undefined if the document is not ready.\n     */\n    docSync() {\n        if (!this.isReady())\n            return undefined;\n        else\n            return this.#doc;\n    }\n    /**\n     * Returns the current \"heads\" of the document, akin to a git commit.\n     * This precisely defines the state of a document.\n     * @returns the current document's heads, or undefined if the document is not ready\n     */\n    heads() {\n        if (!this.isReady()) {\n            return undefined;\n        }\n        return A.getHeads(this.#doc);\n    }\n    /**\n     * Creates a fixed \"view\" of an automerge document at the given point in time represented\n     * by the `heads` passed in. The return value is the same type as docSync() and will return\n     * undefined if the object hasn't finished loading.\n     *\n     * @remarks\n     * A point-in-time in an automerge document is an *array* of heads since there may be\n     * concurrent edits. This API just returns a topologically sorted history of all edits\n     * so every previous entry will be (in some sense) before later ones, but the set of all possible\n     * history views would be quite large under concurrency (every thing in each branch against each other).\n     * There might be a clever way to think about this, but we haven't found it yet, so for now at least\n     * we present a single traversable view which excludes concurrency.\n     * @returns The individual heads for every change in the document.\n     */\n    history() {\n        if (!this.isReady()) {\n            return undefined;\n        }\n        // This just returns all the heads as individual strings.\n        return A.topoHistoryTraversal(this.#doc).map(h =\u003e [h]);\n    }\n    /**\n     * Creates a fixed \"view\" of an automerge document at the given point in time represented\n     * by the `heads` passed in. The return value is the same type as docSync() and will return\n     * undefined if the object hasn't finished loading.\n     *\n     * @remarks\n     * Note that our Typescript types do not consider change over time and the current version\n     * of Automerge doesn't check types at runtime, so if you go back to an old set of heads\n     * that doesn't match the heads here, Typescript will not save you.\n     *\n     * @returns An Automerge.Doc\u003cT\u003e at the point in time.\n     */\n    view(heads) {\n        if (!this.isReady()) {\n            return undefined;\n        }\n        return A.view(this.#doc, heads);\n    }\n    /**\n     * Returns a set of Patch operations that will move a materialized document from one state to another\n     * if applied.\n     *\n     * @remarks\n     * We allow specifying both a from/to heads or just a single comparison point, in which case\n     * the base will be the current document heads.\n     *\n     * @returns Automerge patches that go from one document state to the other. Use view() to get the full state.\n     */\n    diff(first, second) {\n        if (!this.isReady()) {\n            return undefined;\n        }\n        // We allow only one set of heads to be specified, in which case we use the doc's heads\n        const from = second ? first : this.heads() || []; // because we guard above this should always have useful data\n        const to = second ? second : first;\n        return A.diff(this.#doc, from, to);\n    }\n    /**\n     * `metadata(head?)` allows you to look at the metadata for a change\n     * this can be used to build history graphs to find commit messages and edit times.\n     * this interface.\n     *\n     * @remarks\n     * I'm really not convinced this is the right way to surface this information so\n     * I'm leaving this API \"hidden\".\n     *\n     * @hidden\n     */\n    metadata(change) {\n        if (!this.isReady()) {\n            return undefined;\n        }\n        if (!change) {\n            change = this.heads()[0];\n        }\n        // we return undefined instead of null by convention in this API\n        return A.inspectChange(this.#doc, change) || undefined;\n    }\n    /**\n     * `update` is called any time we have a new document state; could be\n     * from a local change, a remote change, or a new document from storage.\n     * Does not cause state changes.\n     * @hidden\n     */\n    update(callback) {\n        this.#machine.send({ type: UPDATE, payload: { callback } });\n    }\n    /**\n     * `doneLoading` is called by the repo after it decides it has all the changes\n     * it's going to get during setup. This might mean it was created locally,\n     * or that it was loaded from storage, or that it was received from a peer.\n     */\n    doneLoading() {\n        this.#machine.send({ type: DOC_READY });\n    }\n    /**\n     * Called by the repo either when a doc handle changes or we receive new remote heads.\n     * @hidden\n     */\n    setRemoteHeads(storageId, heads) {\n        this.#remoteHeads[storageId] = heads;\n        this.emit(\"remote-heads\", { storageId, heads });\n    }\n    /** Returns the heads of the storageId. */\n    getRemoteHeads(storageId) {\n        return this.#remoteHeads[storageId];\n    }\n    /**\n     * All changes to an Automerge document should be made through this method.\n     * Inside the callback, the document should be treated as mutable: all edits will be recorded\n     * using a Proxy and translated into operations as part of a single recorded \"change\".\n     *\n     * Note that assignment via ES6 spread operators will result in *replacing* the object\n     * instead of mutating it which will prevent clean merges. This may be what you want, but\n     * `doc.foo = { ...doc.foo, bar: \"baz\" }` is not equivalent to `doc.foo.bar = \"baz\"`.\n     *\n     * Local changes will be stored (by the StorageSubsystem) and synchronized (by the\n     * DocSynchronizer) to any peers you are sharing it with.\n     *\n     * @param callback - A function that takes the current document and mutates it.\n     *\n     */\n    change(callback, options = {}) {\n        if (!this.isReady()) {\n            throw new Error(`DocHandle#${this.documentId} is in ${this.state} and not ready. Check \\`handle.isReady()\\` before accessing the document.`);\n        }\n        this.#machine.send({\n            type: UPDATE,\n            payload: { callback: doc =\u003e A.change(doc, options, callback) },\n        });\n    }\n    /**\n     * Makes a change as if the document were at `heads`.\n     *\n     * @returns A set of heads representing the concurrent change that was made.\n     */\n    changeAt(heads, callback, options = {}) {\n        if (!this.isReady()) {\n            throw new Error(`DocHandle#${this.documentId} is not ready. Check \\`handle.isReady()\\` before accessing the document.`);\n        }\n        let resultHeads = undefined;\n        this.#machine.send({\n            type: UPDATE,\n            payload: {\n                callback: doc =\u003e {\n                    const result = A.changeAt(doc, heads, options, callback);\n                    resultHeads = result.newHeads || undefined;\n                    return result.newDoc;\n                },\n            },\n        });\n        // the callback above will always run before we get here, so this should always contain the new heads\n        return resultHeads;\n    }\n    /**\n     * Merges another document into this document. Any peers we are sharing changes with will be\n     * notified of the changes resulting from the merge.\n     *\n     * @returns the merged document.\n     *\n     * @throws if either document is not ready or if `otherHandle` is unavailable.\n     */\n    merge(\n    /** the handle of the document to merge into this one */\n    otherHandle) {\n        if (!this.isReady() || !otherHandle.isReady()) {\n            throw new Error(\"Both handles must be ready to merge\");\n        }\n        const mergingDoc = otherHandle.docSync();\n        if (!mergingDoc) {\n            throw new Error(\"The document to be merged in is falsy, aborting.\");\n        }\n        this.update(doc =\u003e {\n            return A.merge(doc, mergingDoc);\n        });\n    }\n    /**\n     * Used in testing to mark this document as unavailable.\n     * @hidden\n     */\n    unavailable() {\n        this.#machine.send({ type: DOC_UNAVAILABLE });\n    }\n    /** Called by the repo when the document is not found in storage.\n     * @hidden\n     * */\n    request() {\n        if (this.#state === \"loading\")\n            this.#machine.send({ type: REQUEST });\n    }\n    /** Called by the repo when the document is deleted. */\n    delete() {\n        this.#machine.send({ type: DELETE });\n    }\n    /**\n     * Sends an arbitrary ephemeral message out to all reachable peers who would receive sync messages\n     * from you. It has no guarantee of delivery, and is not persisted to the underlying automerge doc\n     * in any way. Messages will have a sending PeerId but this is *not* a useful user identifier (a\n     * user could have multiple tabs open and would appear as multiple PeerIds). Every message source\n     * must have a unique PeerId.\n     */\n    broadcast(message) {\n        this.emit(\"ephemeral-message-outbound\", {\n            handle: this,\n            data: encode(message),\n        });\n    }\n    metrics() {\n        return A.stats(this.#doc);\n    }\n}\n// STATE MACHINE TYPES \u0026 CONSTANTS\n// state\n/**\n * Possible internal states for a DocHandle\n */\nexport const HandleState = {\n    /** The handle has been created but not yet loaded or requested */\n    IDLE: \"idle\",\n    /** We are waiting for storage to finish loading */\n    LOADING: \"loading\",\n    /** We are waiting for someone in the network to respond to a sync request */\n    REQUESTING: \"requesting\",\n    /** The document is available */\n    READY: \"ready\",\n    /** The document has been deleted from the repo */\n    DELETED: \"deleted\",\n    /** The document was not available in storage or from any connected peers */\n    UNAVAILABLE: \"unavailable\",\n};\nexport const { IDLE, LOADING, REQUESTING, READY, DELETED, UNAVAILABLE } = HandleState;\nconst BEGIN = \"BEGIN\";\nconst REQUEST = \"REQUEST\";\nconst DOC_READY = \"DOC_READY\";\nconst UPDATE = \"UPDATE\";\nconst DELETE = \"DELETE\";\nconst TIMEOUT = \"TIMEOUT\";\nconst DOC_UNAVAILABLE = \"DOC_UNAVAILABLE\";\n","import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n","import * as Uuid from \"uuid\";\nimport bs58check from \"bs58check\";\nexport const urlPrefix = \"automerge:\";\n/** Given an Automerge URL, returns the DocumentId in both base58check-encoded form and binary form */\nexport const parseAutomergeUrl = (url) =\u003e {\n    const regex = new RegExp(`^${urlPrefix}(\\\\w+)$`);\n    const [, docMatch] = url.match(regex) || [];\n    const documentId = docMatch;\n    const binaryDocumentId = documentIdToBinary(documentId);\n    if (!binaryDocumentId)\n        throw new Error(\"Invalid document URL: \" + url);\n    return {\n        /** unencoded DocumentId */\n        binaryDocumentId,\n        /** encoded DocumentId */\n        documentId,\n    };\n};\n/**\n * Given a documentId in either binary or base58check-encoded form, returns an Automerge URL.\n * Throws on invalid input.\n */\nexport const stringifyAutomergeUrl = (arg) =\u003e {\n    const documentId = arg instanceof Uint8Array || typeof arg === \"string\"\n        ? arg\n        : \"documentId\" in arg\n            ? arg.documentId\n            : undefined;\n    const encodedDocumentId = documentId instanceof Uint8Array\n        ? binaryToDocumentId(documentId)\n        : typeof documentId === \"string\"\n            ? documentId\n            : undefined;\n    if (encodedDocumentId === undefined)\n        throw new Error(\"Invalid documentId: \" + documentId);\n    return (urlPrefix + encodedDocumentId);\n};\n/**\n * Given a string, returns true if it is a valid Automerge URL. This function also acts as a type\n * discriminator in Typescript.\n */\nexport const isValidAutomergeUrl = (str) =\u003e {\n    if (typeof str !== \"string\")\n        return false;\n    if (!str || !str.startsWith(urlPrefix))\n        return false;\n    const automergeUrl = str;\n    try {\n        const { documentId } = parseAutomergeUrl(automergeUrl);\n        return isValidDocumentId(documentId);\n    }\n    catch {\n        return false;\n    }\n};\nexport const isValidDocumentId = (str) =\u003e {\n    if (typeof str !== \"string\")\n        return false;\n    // try to decode from base58\n    const binaryDocumentID = documentIdToBinary(str);\n    if (binaryDocumentID === undefined)\n        return false; // invalid base58check encoding\n    // confirm that the document ID is a valid UUID\n    const documentId = Uuid.stringify(binaryDocumentID);\n    return Uuid.validate(documentId);\n};\nexport const isValidUuid = (str) =\u003e typeof str === \"string\" \u0026\u0026 Uuid.validate(str);\n/**\n * Returns a new Automerge URL with a random UUID documentId. Called by Repo.create(), and also used by tests.\n */\nexport const generateAutomergeUrl = () =\u003e {\n    const documentId = Uuid.v4(null, new Uint8Array(16));\n    return stringifyAutomergeUrl({ documentId });\n};\nexport const documentIdToBinary = (docId) =\u003e bs58check.decodeUnsafe(docId);\nexport const binaryToDocumentId = (docId) =\u003e bs58check.encode(docId);\nexport const parseLegacyUUID = (str) =\u003e {\n    if (!Uuid.validate(str))\n        return undefined;\n    const documentId = Uuid.parse(str);\n    return stringifyAutomergeUrl({ documentId });\n};\n/**\n * Given any valid expression of a document ID, returns a DocumentId in base58check-encoded form.\n *\n * Currently supports:\n * - base58check-encoded DocumentId\n * - Automerge URL\n * - legacy UUID\n * - binary DocumentId\n *\n * Throws on invalid input.\n */\nexport const interpretAsDocumentId = (id) =\u003e {\n    // binary\n    if (id instanceof Uint8Array)\n        return binaryToDocumentId(id);\n    // url\n    if (isValidAutomergeUrl(id))\n        return parseAutomergeUrl(id).documentId;\n    // base58check\n    if (isValidDocumentId(id))\n        return id;\n    // legacy UUID\n    if (isValidUuid(id)) {\n        console.warn(\"Future versions will not support UUIDs as document IDs; use Automerge URLs instead.\");\n        const binaryDocumentID = Uuid.parse(id);\n        return binaryToDocumentId(binaryDocumentID);\n    }\n    // none of the above\n    throw new Error(`Invalid AutomergeUrl: '${id}'`);\n};\n","import { Encoder, decode as cborXdecode } from \"cbor-x\";\nexport function encode(obj) {\n    const encoder = new Encoder({ tagUint8Array: false, useRecords: false });\n    return encoder.encode(obj);\n}\nexport function decode(buf) {\n    return cborXdecode(buf);\n}\n","let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet maxArraySize = 112810000 // This is the maximum array size in V8. We would potentially detect and set it higher\n// for JSC, but this is pretty large and should be sufficient for most use cases\nlet maxMapSize = 16810000 // JavaScript has a fixed maximum map size of about 16710000, but JS itself enforces this,\n// so we don't need to\n\nlet maxObjectSize = 16710000; // This is the maximum number of keys in a Map. It takes over a minute to create this\n// many keys in an object, so also probably a reasonable choice there.\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\nlet inlineObjectReadThreshold = 2;\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\n\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) \u0026\u0026 !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false \u0026\u0026 options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared \u0026\u0026 !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap \u0026\u0026 this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) =\u003e res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) =\u003e res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r =\u003e this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() =\u003e {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end \u003e -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source \u0026\u0026 typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues \u0026\u0026\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length \u003e 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length \u003e 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position \u003c size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position \u003c size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position \u003e= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position \u003e srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token \u003e\u003e 5\n\ttoken = token \u0026 0x1f\n\tif (token \u003e 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 \u003e 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] \u0026 0x7f) \u003c\u003c 1) | (src[position + 1] \u003e\u003e 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value \u003e 0 ? 0.5 : -0.5)) \u003e\u003e 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType \u003e 1) {\n\t\t\t\t\tif (dataView.getUint32(position) \u003e 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tif (i \u003e= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ \u003e= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ \u003e= maxMapSize) throw new Error(`Property count exceeds ${maxMapSize}`)\n\t\t\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ \u003e= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\twhile ((key = read()) != STOP_CODE) {\n\t\t\t\t\t\t\t\t\tif (i++ \u003e= maxMapSize) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error(`Map size exceeds ${maxMapSize}`);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmap.set(key, read())\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd \u003e= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 \u0026\u0026 srcEnd \u003c 140 \u0026\u0026 token \u003c 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token \u003c 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tif (token \u003e= maxArraySize) throw new Error(`Array length exceeds ${maxArraySize}`)\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i \u003c token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i \u003c token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (token \u003e= maxMapSize) throw new Error(`Map size exceeds ${maxArraySize}`)\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i \u003c token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i \u003c token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i \u003c token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i \u003c token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token \u003e= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token \u0026 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token \u003e= 8 \u0026\u0026 (token \u003c 16 || (token \u003e 0x80 \u0026\u0026 token \u003c 0xc0) || (token \u003e 0x130 \u0026\u0026 token \u003c 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token \u003c 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) { // we do a special check for this so that we can keep the\n\t\t\t\t\t\t// currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tlet structure = read()\n\t\t\t\t\t\trecordDefinition(id, structure)\n\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\tif (currentDecoder.keyMap) for (let i = 2; i \u003c length; i++) {\n\t\t\t\t\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse for (let i = 2; i \u003c length; i++) {\n\t\t\t\t\t\t\tlet key = structure[i - 2]\n\t\t\t\t\t\t\tobject[safeKey(key)] = read()\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn object\n\t\t\t\t\t}\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i \u003c length; i++) {\n\t\t\t\t\t\t\trecordDefinition(id++, read())\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token \u0026 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i \u003c currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tif (!structure) throw new Error('Structure is required in record definition');\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token \u003e\u003e 5\n\t\tlength = length \u0026 0x1f\n\t\tif (length \u003e 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ \u003e= inlineObjectReadThreshold) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k =\u003e currentDecoder.decodeKey(k)).map(k =\u003e validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key =\u003e validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i \u003c length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i \u003c length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\t// protect against prototype pollution\n\tif (typeof key === 'string') return key === '__proto__' ? '__proto_' : key\n\tif (typeof key === 'number' || typeof key === 'boolean' || typeof key === 'bigint') return key.toString();\n\tif (key == null) return key + '';\n\t// protect against expensive (DoS) string conversions\n\tthrow new Error('Invalid property name type ' + typeof key);\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength \u003c= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length \u003c 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length \u003e 64 \u0026\u0026 decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position \u003c end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 \u0026 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 \u0026 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] \u0026 0x3f\n\t\t\tunits.push(((byte1 \u0026 0x1f) \u003c\u003c 6) | byte2)\n\t\t} else if ((byte1 \u0026 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] \u0026 0x3f\n\t\t\tconst byte3 = src[position++] \u0026 0x3f\n\t\t\tunits.push(((byte1 \u0026 0x1f) \u003c\u003c 12) | (byte2 \u003c\u003c 6) | byte3)\n\t\t} else if ((byte1 \u0026 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] \u0026 0x3f\n\t\t\tconst byte3 = src[position++] \u0026 0x3f\n\t\t\tconst byte4 = src[position++] \u0026 0x3f\n\t\t\tlet unit = ((byte1 \u0026 0x07) \u003c\u003c 0x12) | (byte2 \u003c\u003c 0x0c) | (byte3 \u003c\u003c 0x06) | byte4\n\t\t\tif (unit \u003e 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit \u003e\u003e\u003e 10) \u0026 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit \u0026 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length \u003e= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length \u003e 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i \u003c length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte \u0026 0x80) \u003e 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length \u003c 4) {\n\t\tif (length \u003c 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a \u0026 0x80) \u003e 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a \u0026 0x80) \u003e 0 || (b \u0026 0x80) \u003e 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length \u003c 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c \u0026 0x80) \u003e 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a \u0026 0x80) \u003e 0 || (b \u0026 0x80) \u003e 0 || (c \u0026 0x80) \u003e 0 || (d \u0026 0x80) \u003e 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length \u003c 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e \u0026 0x80) \u003e 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length \u003c 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e \u0026 0x80) \u003e 0 || (f \u0026 0x80) \u003e 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length \u003c 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g \u0026 0x80) \u003e 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e \u0026 0x80) \u003e 0 || (f \u0026 0x80) \u003e 0 || (g \u0026 0x80) \u003e 0 || (h \u0026 0x80) \u003e 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length \u003c 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i \u0026 0x80) \u003e 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length \u003c 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i \u0026 0x80) \u003e 0 || (j \u0026 0x80) \u003e 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length \u003c 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k \u0026 0x80) \u003e 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i \u0026 0x80) \u003e 0 || (j \u0026 0x80) \u003e 0 || (k \u0026 0x80) \u003e 0 || (l \u0026 0x80) \u003e 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length \u003c 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m \u0026 0x80) \u003e 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m \u0026 0x80) \u003e 0 || (n \u0026 0x80) \u003e 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length \u003c 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o \u0026 0x80) \u003e 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 \u0026 0x7f) \u003e\u003e 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 \u0026 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 \u0026 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 \u0026 3) \u003c\u003c 8) | byte1) / (1 \u003c\u003c 24)\n\t\treturn (byte0 \u0026 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 \u0026 0x80) | // sign bit\n\t\t((exponent \u003e\u003e 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 \u0026 7) \u003c\u003c 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 \u003e\u003e 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 \u003c\u003c 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length \u003e= 0x60 \u0026\u0026 length \u003c 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd \u003e= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 \u0026\u0026 srcEnd \u003c 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length \u003c\u003c 5) ^ (length \u003e 1 ? dataView.getUint16(position) : length \u003e 0 ? src[position] : 0)) \u0026 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry \u0026\u0026 entry.bytes == length) {\n\t\twhile (checkPosition \u003c end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition \u003c end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition \u003c end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition \u003c end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length \u003c 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) =\u003e {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) =\u003e {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) =\u003e {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i \u003c l; i++) {\n\t\tvalue = BigInt(buffer[i]) + (value \u003c\u003c BigInt(8))\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) =\u003e {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) =\u003e {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) =\u003e {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (id, structure) =\u003e {\n\tid = id - 0xe000\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure \u0026\u0026 existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = (data) =\u003e {\n\tlet length = data.length\n\tlet structure = data[1]\n\trecordDefinition(data[0], structure)\n\tlet object = {}\n\tfor (let i = 2; i \u003c length; i++) {\n\t\tlet key = structure[i - 2]\n\t\tobject[safeKey(key)] = data[i]\n\t}\n\treturn object\n}\ncurrentExtensions[14] = (value) =\u003e {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) =\u003e {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) =\u003e { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) =\u003e {\n\tif (src[position++] != 0x84) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\tif (src.length \u003c position)\n\t\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tlet newPackedValues = read() // packed values\n\tif (!newPackedValues || !newPackedValues.length) {\n\t\tlet error = new Error('Packed values structure must be followed by a 4 element array')\n\t\terror.incomplete = true\n\t\tthrow error\n\t}\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) =\u003e { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data \u003e= 0 ? 2 * data : (-2 * data - 1))]\n\tlet error = new Error('No support for non-integer packed references yet')\n\tif (data === undefined)\n\t\terror.incomplete = true\n\tthrow error\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) =\u003e {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) =\u003e {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) =\u003e { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet startingPosition = position\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token \u003e\u003e 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) {// there is a cycle, so we have to assign properties to original target\n\t\tif (Object.getPrototypeOf(target) !== Object.getPrototypeOf(targetProperties)) {\n\t\t\t// this means that the returned target does not match the targetProperties, so we need rerun the read to\n\t\t\t// have the correctly create instance be assigned as a reference, then we do the copy the properties back to the\n\t\t\t// target\n\t\t\t// reset the position so that the read can be repeated\n\t\t\tposition = startingPosition\n\t\t\t// the returned instance is our new target for references\n\t\t\ttarget = targetProperties\n\t\t\treferenceMap.set(id, { target })\n\t\t\ttargetProperties = read()\n\t\t}\n\t\treturn Object.assign(target, targetProperties)\n\t}\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) =\u003e {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) =\u003e new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) =\u003e {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) =\u003e {\n\tif (tag \u003e= 225 \u0026\u0026 tag \u003c= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag \u003e= 28704 \u0026\u0026 tag \u003c= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag \u003e= 1879052288 \u0026\u0026 tag \u003c= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag \u003e= 216 \u0026\u0026 tag \u003c= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag \u003e= 27647 \u0026\u0026 tag \u003c= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag \u003e= 1811940352 \u0026\u0026 tag \u003c= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i \u003c typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tlet bytesPerElement;\n\tif (typeof TypedArray === 'function')\n\t\tbytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n\telse\n\t\tTypedArray = null;\n\tfor (let littleEndian = 0; littleEndian \u003c 2; littleEndian++) {\n\t\tif (!littleEndian \u0026\u0026 bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : bytesPerElement == 8 ? 3 : 0\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) =\u003e {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tif (!currentDecoder.copyBuffers) {\n\t\t\t\t// try provide a direct view, but will only work if we are byte-aligned\n\t\t\t\tif (bytesPerElement === 1 ||\n\t\t\t\t\tbytesPerElement === 2 \u0026\u0026 !(buffer.byteOffset \u0026 1) ||\n\t\t\t\t\tbytesPerElement === 4 \u0026\u0026 !(buffer.byteOffset \u0026 3) ||\n\t\t\t\t\tbytesPerElement === 8 \u0026\u0026 !(buffer.byteOffset \u0026 7))\n\t\t\t\t\treturn new TypedArray(buffer.buffer, buffer.byteOffset, buffer.byteLength \u003e\u003e sizeShift);\n\t\t\t}\n\t\t\t// we have to slice/copy here to get a new ArrayBuffer, if we are not word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer =\u003e {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length \u003e\u003e sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i \u003c elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i \u003c\u003c sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i \u003c length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] \u0026 0x1f\n\tif (token \u003e 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() =\u003e {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport function setSizeLimits(limits) {\n\tif (limits.maxMapSize) maxMapSize = limits.maxMapSize;\n\tif (limits.maxArraySize) maxArraySize = limits.maxArraySize;\n\tif (limits.maxObjectSize) maxObjectSize = limits.maxObjectSize;\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i \u003c 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] \u0026 0x7f) \u003c\u003c 1) | (u8Array[2] \u003e\u003e 7)]\n\treturn ((multiplier * float32Number + (float32Number \u003e 0 ? 0.5 : -0.5)) \u003e\u003e 0) / multiplier\n}\n","import { Decoder, mult10, Tag, typedArrays, addExtension as decodeAddExtension } from './decode.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst Buffer = typeof globalThis === 'object' \u0026\u0026 globalThis.Buffer;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_STRUCTURES = 0x100\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet serializationId = 1\nlet throwOnIterable\nlet target\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nconst MAX_BUNDLE_SIZE = 0xf000\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nconst RECORD_SYMBOL = Symbol('record-id')\nexport class Encoder extends Decoder {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet sharedStructures\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\toptions = options || {}\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position, maxBytes) {\n\t\t\treturn target.utf8Write(string, position, maxBytes)\n\t\t} : (textEncoder \u0026\u0026 textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet encoder = this\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 128 : 0\n\t\tif (maxSharedStructures \u003e 8190)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8190')\n\t\tlet isSequential = options.sequential\n\t\tif (isSequential) {\n\t\t\tmaxSharedStructures = 0\n\t\t}\n\t\tif (!this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.saveStructures)\n\t\t\tthis.saveShared = this.saveStructures\n\t\tlet samplingPackedValues, packedObjectMap, sharedValues = options.sharedValues\n\t\tlet sharedPackedObjectMap\n\t\tif (sharedValues) {\n\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\tfor (let i = 0, l = sharedValues.length; i \u003c l; i++) {\n\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t}\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\t\t\n\t\tthis.mapEncode = function(value, encodeOptions) {\n\t\t\t// Experimental support for premapping keys using _keyMap instad of keyMap - not optiimised yet)\n\t\t\tif (this._keyMap \u0026\u0026 !this._mapped) {\n\t\t\t\t//console.log('encoding ', value)\n\t\t\t\tswitch (value.constructor.name) {\n\t\t\t\t\tcase 'Array': \n\t\t\t\t\t\tvalue = value.map(r =\u003e this.encodeKeys(r))\n\t\t\t\t\t\tbreak\n\t\t\t\t\t//case 'Map': \n\t\t\t\t\t//\tvalue = this.encodeKeys(value)\n\t\t\t\t\t//\tbreak\n\t\t\t\t}\n\t\t\t\t//this._mapped = true\n\t\t\t}\n\t\t\treturn this.encode(value, encodeOptions)\n\t\t}\n\t\t\n\t\tthis.encode = function(value, encodeOptions)\t{\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, 8192)\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position \u003c 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = new DataView(target.buffer, 0, target.length)\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else if (encodeOptions === REUSE_BUFFER_MODE)\n\t\t\t\tposition = (position + 7) \u0026 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encoder.useSelfDescribedHeader) {\n\t\t\t\ttargetView.setUint32(position, 0xd9d9f700) // tag two byte, then self-descriptive tag\n\t\t\t\tposition += 3\n\t\t\t}\n\t\t\treferenceMap = encoder.structuredClone ? new Map() : null\n\t\t\tif (encoder.bundleStrings \u0026\u0026 typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\n\t\t\tsharedStructures = encoder.structures\n\t\t\tif (sharedStructures) {\n\t\t\t\tif (sharedStructures.uninitialized) {\n\t\t\t\t\tlet sharedData = encoder.getShared() || {}\n\t\t\t\t\tencoder.structures = sharedStructures = sharedData.structures || []\n\t\t\t\t\tencoder.sharedVersion = sharedData.version\n\t\t\t\t\tlet sharedValues = encoder.sharedValues = sharedData.packedValues\n\t\t\t\t\tif (sharedValues) {\n\t\t\t\t\t\tsharedPackedObjectMap = {}\n\t\t\t\t\t\tfor (let i = 0, l = sharedValues.length; i \u003c l; i++)\n\t\t\t\t\t\t\tsharedPackedObjectMap[sharedValues[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet sharedStructuresLength = sharedStructures.length\n\t\t\t\tif (sharedStructuresLength \u003e maxSharedStructures \u0026\u0026 !isSequential)\n\t\t\t\t\tsharedStructuresLength = maxSharedStructures\n\t\t\t\tif (!sharedStructures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tsharedStructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i \u003c sharedStructuresLength; i++) {\n\t\t\t\t\t\tlet keys = sharedStructures[i]\n\t\t\t\t\t\t//console.log('shared struct keys:', keys)\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = sharedStructures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j \u003c l; j++) {\n\t\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined)\n\t\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i | 0x100000\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!isSequential)\n\t\t\t\t\tsharedStructures.nextId = sharedStructuresLength\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tstructures = sharedStructures || []\n\t\t\tpackedObjectMap = sharedPackedObjectMap\n\t\t\tif (options.pack) {\n\t\t\t\tlet packedValues = new Map()\n\t\t\t\tpackedValues.values = []\n\t\t\t\tpackedValues.encoder = encoder\n\t\t\t\tpackedValues.maxValues = options.maxPrivatePackedValues || (sharedPackedObjectMap ? 16 : Infinity)\n\t\t\t\tpackedValues.objectMap = sharedPackedObjectMap || false\n\t\t\t\tpackedValues.samplingPackedValues = samplingPackedValues\n\t\t\t\tfindRepetitiveStrings(value, packedValues)\n\t\t\t\tif (packedValues.values.length \u003e 0) {\n\t\t\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\twriteArrayHeader(4)\n\t\t\t\t\tlet valuesArray = packedValues.values\n\t\t\t\t\tencode(valuesArray)\n\t\t\t\t\twriteArrayHeader(0) // prefixes\n\t\t\t\t\twriteArrayHeader(0) // suffixes\n\t\t\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\t\t\tfor (let i = 0, l = valuesArray.length; i \u003c l; i++) {\n\t\t\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrowOnIterable = encodeOptions \u0026 THROW_ON_ITERABLE;\n\t\t\ttry {\n\t\t\t\tif (throwOnIterable)\n\t\t\t\t\treturn;\n\t\t\t\tencode(value)\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\twriteBundles(start, encode)\n\t\t\t\t}\n\t\t\t\tencoder.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (referenceMap \u0026\u0026 referenceMap.idsToInsert) {\n\t\t\t\t\tposition += referenceMap.idsToInsert.length * 2\n\t\t\t\t\tif (position \u003e safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tencoder.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), referenceMap.idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tif (encodeOptions \u0026 REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call encode again in saveShared, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (sharedStructures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild \u003c 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tif (sharedStructures.length \u003e maxSharedStructures)\n\t\t\t\t\t\tsharedStructures.length = maxSharedStructures\n\t\t\t\t\tif (transitionsCount \u003e 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tsharedStructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length \u003e 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length \u003e 0 \u0026\u0026 !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i \u003c l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t\t//sharedStructures.nextId = maxSharedStructures\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (hasSharedUpdate \u0026\u0026 encoder.saveShared) {\n\t\t\t\t\tif (encoder.structures.length \u003e maxSharedStructures) {\n\t\t\t\t\t\tencoder.structures = encoder.structures.slice(0, maxSharedStructures)\n\t\t\t\t\t}\n\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\tif (encoder.updateSharedData() === false)\n\t\t\t\t\t\treturn encoder.encode(value) // re-encode if it fails\n\t\t\t\t\treturn returnBuffer\n\t\t\t\t}\n\t\t\t\tif (encodeOptions \u0026 RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tthis.findCommonStringsToPack = () =\u003e {\n\t\t\tsamplingPackedValues = new Map()\n\t\t\tif (!sharedPackedObjectMap)\n\t\t\t\tsharedPackedObjectMap = Object.create(null)\n\t\t\treturn (options) =\u003e {\n\t\t\t\tlet threshold = options \u0026\u0026 options.threshold || 4\n\t\t\t\tlet position = this.pack ? options.maxPrivatePackedValues || 16 : 0\n\t\t\t\tif (!sharedValues)\n\t\t\t\t\tsharedValues = this.sharedValues = []\n\t\t\t\tfor (let [ key, status ] of samplingPackedValues) {\n\t\t\t\t\tif (status.count \u003e threshold) {\n\t\t\t\t\t\tsharedPackedObjectMap[key] = position++\n\t\t\t\t\t\tsharedValues.push(key)\n\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (this.saveShared \u0026\u0026 this.updateSharedData() === false) {}\n\t\t\t\tsamplingPackedValues = null\n\t\t\t}\n\t\t}\n\t\tconst encode = (value) =\u003e {\n\t\t\tif (position \u003e safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tif (packedObjectMap) {\n\t\t\t\t\tlet packedPosition = packedObjectMap[value]\n\t\t\t\t\tif (packedPosition \u003e= 0) {\n\t\t\t\t\t\tif (packedPosition \u003c 16)\n\t\t\t\t\t\t\ttarget[position++] = packedPosition + 0xe0 // simple values, defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc6 // tag 6 defined in https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\t\t\t\t\tif (packedPosition \u0026 1)\n\t\t\t\t\t\t\t\tencode((15 - packedPosition) \u003e\u003e 1)\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tencode((packedPosition - 16) \u003e\u003e 1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n/*\t\t\t\t\t\t} else if (packedStatus.serializationId != serializationId) {\n\t\t\t\t\t\t\tpackedStatus.serializationId = serializationId\n\t\t\t\t\t\t\tpackedStatus.count = 1\n\t\t\t\t\t\t\tif (options.sharedPack) {\n\t\t\t\t\t\t\t\tlet sharedCount = packedStatus.sharedCount = (packedStatus.sharedCount || 0) + 1\n\t\t\t\t\t\t\t\tif (shareCount \u003e (options.sharedPack.threshold || 5)) {\n\t\t\t\t\t\t\t\t\tlet sharedPosition = packedStatus.position = packedStatus.nextSharedPosition\n\t\t\t\t\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t\t\t\t\t\tif (sharedPosition \u003c 16)\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = sharedPosition + 0xc0\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // else any in-doc incrementation?*/\n\t\t\t\t\t} else if (samplingPackedValues \u0026\u0026 !options.pack) {\n\t\t\t\t\t\tlet status = samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tsamplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings \u0026\u0026 strLength \u003e= 4 \u0026\u0026 strLength \u003c 0x400) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) \u003e MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes \u003e safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\ttarget[position++] = 0xd9 // tag 16-bit\n\t\t\t\t\t\ttarget[position++] = 0xdf // tag 0xdff9\n\t\t\t\t\t\ttarget[position++] = 0xf9\n\t\t\t\t\t\t// TODO: If we only have one bundle with any string data, only write one string bundle\n\t\t\t\t\t\ttarget[position++] = bundledStrings.position ? 0x84 : 0x82 // array of 4 or 2 elements depending on if we write bundles\n\t\t\t\t\t\ttarget[position++] = 0x1a // 32-bit unsigned int\n\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\tif (bundledStrings.position) {\n\t\t\t\t\t\t\twriteBundles(start, encode) // write the last bundles\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = twoByte ? 0xce : 0xcf\n\t\t\t\t\tencode(strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength \u003c 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength \u003c 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength \u003c 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes \u003e safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength \u003c 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i \u003c strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 \u003c 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 \u003c 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 \u003e\u003e 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 \u0026 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 \u0026 0xfc00) === 0xd800 \u0026\u0026\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) \u0026 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 \u0026 0x03ff) \u003c\u003c 10) + (c2 \u0026 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 \u003e\u003e 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 \u003e\u003e 12 \u0026 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 \u003e\u003e 6 \u0026 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 \u0026 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 \u003e\u003e 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 \u003e\u003e 6 \u0026 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 \u0026 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize, maxBytes)\n\t\t\t\t}\n\n\t\t\t\tif (length \u003c 0x18) {\n\t\t\t\t\ttarget[position++] = 0x60 | length\n\t\t\t\t} else if (length \u003c 0x100) {\n\t\t\t\t\tif (headerSize \u003c 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x78\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length \u003c 0x10000) {\n\t\t\t\t\tif (headerSize \u003c 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x79\n\t\t\t\t\ttarget[position++] = length \u003e\u003e 8\n\t\t\t\t\ttarget[position++] = length \u0026 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize \u003c 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0x7a\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (!this.alwaysUseFloat \u0026\u0026 value \u003e\u003e\u003e 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value \u003c 0x18) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value \u003c 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x18\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value \u003c 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x19\n\t\t\t\t\t\ttarget[position++] = value \u003e\u003e 8\n\t\t\t\t\t\ttarget[position++] = value \u0026 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x1a\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (!this.alwaysUseFloat \u0026\u0026 value \u003e\u003e 0 === value) { // negative integer\n\t\t\t\t\tif (value \u003e= -0x18) {\n\t\t\t\t\t\ttarget[position++] = 0x1f - value\n\t\t\t\t\t} else if (value \u003e= -0x100) {\n\t\t\t\t\t\ttarget[position++] = 0x38\n\t\t\t\t\t\ttarget[position++] = ~value\n\t\t\t\t\t} else if (value \u003e= -0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0x39\n\t\t\t\t\t\ttargetView.setUint16(position, ~value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0x3a\n\t\t\t\t\t\ttargetView.setUint32(position, ~value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) \u003e 0 \u0026\u0026 value \u003c 0x100000000 \u0026\u0026 value \u003e= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xfa\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 \u003c 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] \u0026 0x7f) \u003c\u003c 1) | (target[position + 1] \u003e\u003e 7)]) \u003e\u003e 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xf6\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\ttarget[position++] = 29 // http://cbor.schmorp.de/value-sharing\n\t\t\t\t\t\t\ttarget[position++] = 0x19 // 16-bit uint\n\t\t\t\t\t\t\tif (!referee.references) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.references = []\n\t\t\t\t\t\t\t\tidsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treferee.references.push(position - start)\n\t\t\t\t\t\t\tposition += 2 // TODO: also support 32-bit\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tlength = value.length\n\t\t\t\t\t\tif (length \u003c 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twriteArrayHeader(length)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i \u003c length; i++) {\n\t\t\t\t\t\t\tencode(value[i])\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapsAsObjects ? this.useTag259ForMaps !== false : this.useTag259ForMaps) {\n\t\t\t\t\t\t\t// use Tag 259 (https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md) for maps if the user wants it that way\n\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\ttarget[position++] = 1\n\t\t\t\t\t\t\ttarget[position++] = 3\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length \u003c 0x18) {\n\t\t\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t\t\t} else if (length \u003c 0x100) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\t\t\t\ttarget[position++] = length\n\t\t\t\t\t\t} else if (length \u003c 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\t\t\t\ttarget[position++] = length \u003e\u003e 8\n\t\t\t\t\t\t\ttarget[position++] = length \u0026 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xba\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (encoder.keyMap) { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\t\tencode(key) \n\t\t\t\t\t\t\t\tencode(entryValue)\n\t\t\t\t\t\t\t} \t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i \u003c l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tlet tag = extension.tag\n\t\t\t\t\t\t\t\tif (tag == undefined)\n\t\t\t\t\t\t\t\t\ttag = extension.getTag \u0026\u0026 extension.getTag.call(this, value)\n\t\t\t\t\t\t\t\tif (tag \u003c 0x18) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xc0 | tag\n\t\t\t\t\t\t\t\t} else if (tag \u003c 0x100) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag\n\t\t\t\t\t\t\t\t} else if (tag \u003c 0x10000) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag \u003e\u003e 8\n\t\t\t\t\t\t\t\t\ttarget[position++] = tag \u0026 0xff\n\t\t\t\t\t\t\t\t} else if (tag \u003e -1) {\n\t\t\t\t\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\t\t\t\t\ttargetView.setUint32(position, tag)\n\t\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t\t} // else undefined, don't write tag\n\t\t\t\t\t\t\t\textension.encode.call(this, value, encode, makeRoom)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.iterator]) {\n\t\t\t\t\t\t\tif (throwOnIterable) {\n\t\t\t\t\t\t\t\tlet error = new Error('Iterable should be serialized as iterator')\n\t\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0x9f // indefinite length array\n\t\t\t\t\t\t\tfor (let entry of value) {\n\t\t\t\t\t\t\t\tencode(entry)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xff // stop-code\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value[Symbol.asyncIterator] || isBlob(value)) {\n\t\t\t\t\t\t\tlet error = new Error('Iterable/blob should be serialized as iterator')\n\t\t\t\t\t\t\terror.iteratorNotHandled = true;\n\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.useToJSON \u0026\u0026 value.toJSON) {\n\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\treturn encode(json)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// no extension found, write as a plain object\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xf5 : 0xf4\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value \u003c (BigInt(1)\u003c\u003cBigInt(64)) \u0026\u0026 value \u003e= 0) {\n\t\t\t\t\t// use an unsigned int as long as it fits\n\t\t\t\t\ttarget[position++] = 0x1b\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else if (value \u003e -(BigInt(1)\u003c\u003cBigInt(64)) \u0026\u0026 value \u003c 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0x3b\n\t\t\t\t\ttargetView.setBigUint64(position, -value - BigInt(1))\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xfb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (value \u003e= BigInt(0))\n\t\t\t\t\t\t\ttarget[position++] = 0xc2 // tag 2\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ttarget[position++] = 0xc3 // tag 2\n\t\t\t\t\t\t\tvalue = BigInt(-1) - value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\twhile (value) {\n\t\t\t\t\t\t\tbytes.push(Number(value \u0026 BigInt(0xff)));\n\t\t\t\t\t\t\tvalue \u003e\u003e= BigInt(8);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twriteBuffer(new Uint8Array(bytes.reverse()), makeRoom);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\ttarget[position++] = 0xf7\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) =\u003e {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet vals = Object.values(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length \u003c 0x18) {\n\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t} else if (length \u003c 0x100) {\n\t\t\t\ttarget[position++] = 0xb8\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length \u003c 0x10000) {\n\t\t\t\ttarget[position++] = 0xb9\n\t\t\t\ttarget[position++] = length \u003e\u003e 8\n\t\t\t\ttarget[position++] = length \u0026 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xba\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (encoder.keyMap) { \n\t\t\t\tfor (let i = 0; i \u003c length; i++) {\n\t\t\t\t\tencode(encoder.encodeKey(keys[i]))\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i \u003c length; i++) {\n\t\t\t\t\tencode(keys[i])\n\t\t\t\t\tencode(vals[i])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) =\u003e {\n\t\t\ttarget[position++] = 0xb9 // always use map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tif (encoder.keyMap) {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tencode(encoder.encodeKey(key))\n\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\t\tencode(key)\n\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size \u003e\u003e 8\n\t\t\ttarget[objectOffset + start] = size \u0026 0xff\n\t\t} :\n\t\t(object, skipValues) =\u003e {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tlet length = 0\n\t\t\tlet parentRecordId\n\t\t\tlet keys\n\t\t\tif (this.keyMap) {\n\t\t\t\tkeys = Object.keys(object).map(k =\u003e this.encodeKey(k))\n\t\t\t\tlength = keys.length\n\t\t\t\tfor (let i = 0; i \u003c length; i++) {\n\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t}\t\t\t\t\n\t\t\t} else {\n\t\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] \u0026 0x100000) {// this indicates it is a brancheable/extendable terminal node, so we will use this record id and extend it\n\t\t\t\t\t\t\tparentRecordId = transition[RECORD_SYMBOL] \u0026 0xffff\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t}\n\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\tlength++\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId !== undefined) {\n\t\t\t\trecordId \u0026= 0xffff\n\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\ttarget[position++] = (recordId \u003e\u003e 8) | 0xe0\n\t\t\t\ttarget[position++] = recordId \u0026 0xff\n\t\t\t} else {\n\t\t\t\tif (!keys)\n\t\t\t\t\tkeys = transition.__keys__ || (transition.__keys__ = Object.keys(object))\n\t\t\t\tif (parentRecordId === undefined) {\n\t\t\t\t\trecordId = structures.nextId++\n\t\t\t\t\tif (!recordId) {\n\t\t\t\t\t\trecordId = 0\n\t\t\t\t\t\tstructures.nextId = 1\n\t\t\t\t\t}\n\t\t\t\t\tif (recordId \u003e= MAX_STRUCTURES) {// cycle back around\n\t\t\t\t\t\tstructures.nextId = (recordId = maxSharedStructures) + 1\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trecordId = parentRecordId\n\t\t\t\t}\n\t\t\t\tstructures[recordId] = keys\n\t\t\t\tif (recordId \u003c maxSharedStructures) {\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = (recordId \u003e\u003e 8) | 0xe0\n\t\t\t\t\ttarget[position++] = recordId \u0026 0xff\n\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\tfor (let i = 0; i \u003c length; i++) {\n\t\t\t\t\t\tif (transition[RECORD_SYMBOL] === undefined || (transition[RECORD_SYMBOL] \u0026 0x100000))\n\t\t\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\t\ttransition = transition[keys[i]]\n\t\t\t\t\t}\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId | 0x100000 // indicates it is a extendable terminal\n\t\t\t\t\thasSharedUpdate = true\n\t\t\t\t} else {\n\t\t\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\t\t\ttargetView.setUint32(position, 0xd9dfff00) // tag two byte, then record definition id\n\t\t\t\t\tposition += 3\n\t\t\t\t\tif (newTransitions)\n\t\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\t\tif (recordIdsToRemove.length \u003e= MAX_STRUCTURES - maxSharedStructures)\n\t\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = undefined // we are cycling back through, and have to remove old ones\n\t\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\t\twriteArrayHeader(length + 2)\n\t\t\t\t\tencode(0xe000 + recordId)\n\t\t\t\t\tencode(keys)\n\t\t\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\t\t\tfor (let key in object)\n\t\t\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\t\t\tencode(object[key])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (length \u003c 0x18) { // write the array header\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else {\n\t\t\t\twriteArrayHeader(length)\n\t\t\t}\n\t\t\tif (skipValues) return; // special exit for iterator\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key))\n\t\t\t\t\tencode(object[key])\n\t\t}\n\t\tconst makeRoom = (end) =\u003e {\n\t\t\tlet newSize\n\t\t\tif (end \u003e 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) \u003e MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Encoded buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end \u003e 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) \u003c\u003c 2, target.length - 1) \u003e\u003e 12) + 1) \u003c\u003c 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = new DataView(newBuffer.buffer, 0, newSize)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tlet chunkThreshold = 100;\n\t\tlet continuedChunkThreshold = 1000;\n\t\tthis.encodeAsIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsIterable);\n\t\t}\n\t\tthis.encodeAsAsyncIterable = function(value, options) {\n\t\t\treturn startEncoding(value, options, encodeObjectAsAsyncIterable);\n\t\t}\n\n\t\tfunction* encodeObjectAsIterable(object, iterateProperties, finalIterable) {\n\t\t\tlet constructor = object.constructor;\n\t\t\tif (constructor === Object) {\n\t\t\t\tlet useRecords = encoder.useRecords !== false;\n\t\t\t\tif (useRecords)\n\t\t\t\t\twriteObject(object, true); // write the record identifier\n\t\t\t\telse\n\t\t\t\t\twriteEntityLength(Object.keys(object).length, 0xa0);\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tlet value = object[key];\n\t\t\t\t\tif (!useRecords) encode(key);\n\t\t\t\t\tif (value \u0026\u0026 typeof value === 'object') {\n\t\t\t\t\t\tif (iterateProperties[key])\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties[key]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, key);\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (constructor === Array) {\n\t\t\t\tlet length = object.length;\n\t\t\t\twriteArrayHeader(length);\n\t\t\t\tfor (let i = 0; i \u003c length; i++) {\n\t\t\t\t\tlet value = object[i];\n\t\t\t\t\tif (value \u0026\u0026 (typeof value === 'object' || position - start \u003e chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t} else if (object[Symbol.iterator] \u0026\u0026 !object.buffer) { // iterator, but exclude typed arrays\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tfor (let value of object) {\n\t\t\t\t\tif (value \u0026\u0026 (typeof value === 'object' || position - start \u003e chunkThreshold)) {\n\t\t\t\t\t\tif (iterateProperties.element)\n\t\t\t\t\t\t\tyield* encodeObjectAsIterable(value, iterateProperties.element);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tyield* tryEncode(value, iterateProperties, 'element');\n\t\t\t\t\t} else encode(value);\n\t\t\t\t}\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else if (isBlob(object)){\n\t\t\t\twriteEntityLength(object.size, 0x40); // encode as binary data\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return blobs, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t} else if (object[Symbol.asyncIterator]) {\n\t\t\t\ttarget[position++] = 0x9f; // start indefinite array\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\tyield object; // directly return async iterators, they have to be encoded asynchronously\n\t\t\t\trestartEncoding();\n\t\t\t\ttarget[position++] = 0xff; // stop byte\n\t\t\t} else {\n\t\t\t\tencode(object);\n\t\t\t}\n\t\t\tif (finalIterable \u0026\u0026 position \u003e start) yield target.subarray(start, position);\n\t\t\telse if (position - start \u003e chunkThreshold) {\n\t\t\t\tyield target.subarray(start, position);\n\t\t\t\trestartEncoding();\n\t\t\t}\n\t\t}\n\t\tfunction* tryEncode(value, iterateProperties, key) {\n\t\t\tlet restart = position - start;\n\t\t\ttry {\n\t\t\t\tencode(value);\n\t\t\t\tif (position - start \u003e chunkThreshold) {\n\t\t\t\t\tyield target.subarray(start, position);\n\t\t\t\t\trestartEncoding();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (error.iteratorNotHandled) {\n\t\t\t\t\titerateProperties[key] = {};\n\t\t\t\t\tposition = start + restart; // restart our position so we don't have partial data from last encode\n\t\t\t\t\tyield* encodeObjectAsIterable.call(this, value, iterateProperties[key]);\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t}\n\t\tfunction restartEncoding() {\n\t\t\tchunkThreshold = continuedChunkThreshold;\n\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // restart encoding\n\t\t}\n\t\tfunction startEncoding(value, options, encodeIterable) {\n\t\t\tif (options \u0026\u0026 options.chunkThreshold) // explicitly specified chunk sizes\n\t\t\t\tchunkThreshold = continuedChunkThreshold = options.chunkThreshold;\n\t\t\telse // we start with a smaller threshold to get initial bytes sent quickly\n\t\t\t\tchunkThreshold = 100;\n\t\t\tif (value \u0026\u0026 typeof value === 'object') {\n\t\t\t\tencoder.encode(null, THROW_ON_ITERABLE); // start encoding\n\t\t\t\treturn encodeIterable(value, encoder.iterateProperties || (encoder.iterateProperties = {}), true);\n\t\t\t}\n\t\t\treturn [encoder.encode(value)];\n\t\t}\n\n\t\tasync function* encodeObjectAsAsyncIterable(value, iterateProperties) {\n\t\t\tfor (let encodedValue of encodeObjectAsIterable(value, iterateProperties, true)) {\n\t\t\t\tlet constructor = encodedValue.constructor;\n\t\t\t\tif (constructor === ByteArray || constructor === Uint8Array)\n\t\t\t\t\tyield encodedValue;\n\t\t\t\telse if (isBlob(encodedValue)) {\n\t\t\t\t\tlet reader = encodedValue.stream().getReader();\n\t\t\t\t\tlet next;\n\t\t\t\t\twhile (!(next = await reader.read()).done) {\n\t\t\t\t\t\tyield next.value;\n\t\t\t\t\t}\n\t\t\t\t} else if (encodedValue[Symbol.asyncIterator]) {\n\t\t\t\t\tfor await (let asyncValue of encodedValue) {\n\t\t\t\t\t\trestartEncoding();\n\t\t\t\t\t\tif (asyncValue)\n\t\t\t\t\t\t\tyield* encodeObjectAsAsyncIterable(asyncValue, iterateProperties.async || (iterateProperties.async = {}));\n\t\t\t\t\t\telse yield encoder.encode(asyncValue);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tyield encodedValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.sharedValues)\n\t\t\tthis.sharedValues = undefined\n\t}\n\tupdateSharedData() {\n\t\tlet lastVersion = this.sharedVersion || 0\n\t\tthis.sharedVersion = lastVersion + 1\n\t\tlet structuresCopy = this.structures.slice(0)\n\t\tlet sharedData = new SharedData(structuresCopy, this.sharedValues, this.sharedVersion)\n\t\tlet saveResults = this.saveShared(sharedData,\n\t\t\t\texistingShared =\u003e (existingShared \u0026\u0026 existingShared.version || 0) == lastVersion)\n\t\tif (saveResults === false) {\n\t\t\t// get updated structures and try again if the update failed\n\t\t\tsharedData = this.getShared() || {}\n\t\t\tthis.structures = sharedData.structures || []\n\t\t\tthis.sharedValues = sharedData.packedValues\n\t\t\tthis.sharedVersion = sharedData.version\n\t\t\tthis.structures.nextId = this.structures.length\n\t\t} else {\n\t\t\t// restore structures\n\t\t\tstructuresCopy.forEach((structure, i) =\u003e this.structures[i] = structure)\n\t\t}\n\t\t// saveShared may fail to write and reload, or may have reloaded to check compatibility and overwrite saved data, either way load the correct shared data\n\t\treturn saveResults\n\t}\n}\nfunction writeEntityLength(length, majorValue) {\n\tif (length \u003c 0x18)\n\t\ttarget[position++] = majorValue | length\n\telse if (length \u003c 0x100) {\n\t\ttarget[position++] = majorValue | 0x18\n\t\ttarget[position++] = length\n\t} else if (length \u003c 0x10000) {\n\t\ttarget[position++] = majorValue | 0x19\n\t\ttarget[position++] = length \u003e\u003e 8\n\t\ttarget[position++] = length \u0026 0xff\n\t} else {\n\t\ttarget[position++] = majorValue | 0x1a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\n}\nclass SharedData {\n\tconstructor(structures, values, version) {\n\t\tthis.structures = structures\n\t\tthis.packedValues = values\n\t\tthis.version = version\n\t}\n}\n\nfunction writeArrayHeader(length) {\n\tif (length \u003c 0x18)\n\t\ttarget[position++] = 0x80 | length\n\telse if (length \u003c 0x100) {\n\t\ttarget[position++] = 0x98\n\t\ttarget[position++] = length\n\t} else if (length \u003c 0x10000) {\n\t\ttarget[position++] = 0x99\n\t\ttarget[position++] = length \u003e\u003e 8\n\t\ttarget[position++] = length \u0026 0xff\n\t} else {\n\t\ttarget[position++] = 0x9a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n}\n\nconst BlobConstructor = typeof Blob === 'undefined' ? function(){} : Blob;\nfunction isBlob(object) {\n\tif (object instanceof BlobConstructor)\n\t\treturn true;\n\tlet tag = object[Symbol.toStringTag];\n\treturn tag === 'Blob' || tag === 'File';\n}\nfunction findRepetitiveStrings(value, packedValues) {\n\tswitch(typeof value) {\n\t\tcase 'string':\n\t\t\tif (value.length \u003e 3) {\n\t\t\t\tif (packedValues.objectMap[value] \u003e -1 || packedValues.values.length \u003e= packedValues.maxValues)\n\t\t\t\t\treturn\n\t\t\t\tlet packedStatus = packedValues.get(value)\n\t\t\t\tif (packedStatus) {\n\t\t\t\t\tif (++packedStatus.count == 2) {\n\t\t\t\t\t\tpackedValues.values.push(value)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpackedValues.set(value, {\n\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t})\n\t\t\t\t\tif (packedValues.samplingPackedValues) {\n\t\t\t\t\t\tlet status = packedValues.samplingPackedValues.get(value)\n\t\t\t\t\t\tif (status)\n\t\t\t\t\t\t\tstatus.count++\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tpackedValues.samplingPackedValues.set(value, {\n\t\t\t\t\t\t\t\tcount: 1,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'object':\n\t\t\tif (value) {\n\t\t\t\tif (value instanceof Array) {\n\t\t\t\t\tfor (let i = 0, l = value.length; i \u003c l; i++) {\n\t\t\t\t\t\tfindRepetitiveStrings(value[i], packedValues)\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tlet includeKeys = !packedValues.encoder.useRecords\n\t\t\t\t\tfor (var key in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tif (includeKeys)\n\t\t\t\t\t\t\t\tfindRepetitiveStrings(key, packedValues)\n\t\t\t\t\t\t\tfindRepetitiveStrings(value[key], packedValues)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'function': console.log(value)\n\t}\n}\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nextensionClasses = [ Date, Set, Error, RegExp, Tag, ArrayBuffer,\n\tUint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? function() {} : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? function() {} : BigInt64Array,\n\tFloat32Array, Float64Array, SharedData ]\n\n//Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/\nextensions = [{ // Date\n\ttag: 1,\n\tencode(date, encode) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) \u0026\u0026 seconds \u003e= 0 \u0026\u0026 seconds \u003c 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\ttarget[position++] = 0x1a\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t\tposition += 4\n\t\t} else {\n\t\t\t// Timestamp float64\n\t\t\ttarget[position++] = 0xfb\n\t\t\ttargetView.setFloat64(position, seconds)\n\t\t\tposition += 8\n\t\t}\n\t}\n}, { // Set\n\ttag: 258, // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n\tencode(set, encode) {\n\t\tlet array = Array.from(set)\n\t\tencode(array)\n\t}\n}, { // Error\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(error, encode) {\n\t\tencode([ error.name, error.message ])\n\t}\n}, { // RegExp\n\ttag: 27, // http://cbor.schmorp.de/generic-object\n\tencode(regex, encode) {\n\t\tencode([ 'RegExp', regex.source, regex.flags ])\n\t}\n}, { // Tag\n\tgetTag(tag) {\n\t\treturn tag.tag\n\t},\n\tencode(tag, encode) {\n\t\tencode(tag.value)\n\t}\n}, { // ArrayBuffer\n\tencode(arrayBuffer, encode, makeRoom) {\n\t\twriteBuffer(arrayBuffer, makeRoom)\n\t}\n}, { // Uint8Array\n\tgetTag(typedArray) {\n\t\tif (typedArray.constructor === Uint8Array) {\n\t\t\tif (this.tagUint8Array || hasNodeBuffer \u0026\u0026 this.tagUint8Array !== false)\n\t\t\t\treturn 64;\n\t\t} // else no tag\n\t},\n\tencode(typedArray, encode, makeRoom) {\n\t\twriteBuffer(typedArray, makeRoom)\n\t}\n},\n\ttypedArrayEncoder(68, 1),\n\ttypedArrayEncoder(69, 2),\n\ttypedArrayEncoder(70, 4),\n\ttypedArrayEncoder(71, 8),\n\ttypedArrayEncoder(72, 1),\n\ttypedArrayEncoder(77, 2),\n\ttypedArrayEncoder(78, 4),\n\ttypedArrayEncoder(79, 8),\n\ttypedArrayEncoder(85, 4),\n\ttypedArrayEncoder(86, 8),\n{\n\tencode(sharedData, encode) { // write SharedData\n\t\tlet packedValues = sharedData.packedValues || []\n\t\tlet sharedStructures = sharedData.structures || []\n\t\tif (packedValues.values.length \u003e 0) {\n\t\t\ttarget[position++] = 0xd8 // one-byte tag\n\t\t\ttarget[position++] = 51 // tag 51 for packed shared structures https://www.potaroo.net/ietf/ids/draft-ietf-cbor-packed-03.txt\n\t\t\twriteArrayHeader(4)\n\t\t\tlet valuesArray = packedValues.values\n\t\t\tencode(valuesArray)\n\t\t\twriteArrayHeader(0) // prefixes\n\t\t\twriteArrayHeader(0) // suffixes\n\t\t\tpackedObjectMap = Object.create(sharedPackedObjectMap || null)\n\t\t\tfor (let i = 0, l = valuesArray.length; i \u003c l; i++) {\n\t\t\t\tpackedObjectMap[valuesArray[i]] = i\n\t\t\t}\n\t\t}\n\t\tif (sharedStructures) {\n\t\t\ttargetView.setUint32(position, 0xd9dffe00)\n\t\t\tposition += 3\n\t\t\tlet definitions = sharedStructures.slice(0)\n\t\t\tdefinitions.unshift(0xe000)\n\t\t\tdefinitions.push(new Tag(sharedData.version, 0x53687264))\n\t\t\tencode(definitions)\n\t\t} else\n\t\t\tencode(new Tag(sharedData.version, 0x53687264))\n\t\t}\n\t}]\nfunction typedArrayEncoder(tag, size) {\n\tif (!isLittleEndianMachine \u0026\u0026 size \u003e 1)\n\t\ttag -= 4 // the big endian equivalents are 4 less\n\treturn {\n\t\ttag: tag,\n\t\tencode: function writeExtBuffer(typedArray, encode) {\n\t\t\tlet length = typedArray.byteLength\n\t\t\tlet offset = typedArray.byteOffset || 0\n\t\t\tlet buffer = typedArray.buffer || typedArray\n\t\t\tencode(hasNodeBuffer ? Buffer.from(buffer, offset, length) :\n\t\t\t\tnew Uint8Array(buffer, offset, length))\n\t\t}\n\t}\n}\nfunction writeBuffer(buffer, makeRoom) {\n\tlet length = buffer.byteLength\n\tif (length \u003c 0x18) {\n\t\ttarget[position++] = 0x40 + length\n\t} else if (length \u003c 0x100) {\n\t\ttarget[position++] = 0x58\n\t\ttarget[position++] = length\n\t} else if (length \u003c 0x10000) {\n\t\ttarget[position++] = 0x59\n\t\ttarget[position++] = length \u003e\u003e 8\n\t\ttarget[position++] = length \u0026 0xff\n\t} else {\n\t\ttarget[position++] = 0x5a\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\tif (position + length \u003e= target.length) {\n\t\tmakeRoom(position + length)\n\t}\n\t// if it is already a typed array (has an ArrayBuffer), use that, but if it is an ArrayBuffer itself,\n\t// must wrap it to set it.\n\ttarget.set(buffer.buffer ? buffer : new Uint8Array(buffer), position)\n\tposition += length\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 2\n\tlet lastEnd = serialized.length - distanceToMove\n\tidsToInsert.sort((a, b) =\u003e a.offset \u003e b.offset ? 1 : -1)\n\tfor (let id = 0; id \u003c idsToInsert.length; id++) {\n\t\tlet referee = idsToInsert[id]\n\t\treferee.id = id\n\t\tfor (let position of referee.references) {\n\t\t\tserialized[position++] = id \u003e\u003e 8\n\t\t\tserialized[position] = id \u0026 0xff\n\t\t}\n\t}\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 2\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd8\n\t\tserialized[position++] = 28 // http://cbor.schmorp.de/value-sharing\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\nfunction writeBundles(start, encode) {\n\ttargetView.setUint32(bundledStrings.position + start, position - bundledStrings.position - start + 1) // the offset to bundle\n\tlet writeStrings = bundledStrings\n\tbundledStrings = null\n\tencode(writeStrings[0])\n\tencode(writeStrings[1])\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.encode)\n\t\t\tthrow new Error('Extension has no encode function')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tdecodeAddExtension(extension)\n}\nlet defaultEncoder = new Encoder({ useRecords: false })\nexport const encode = defaultEncoder.encode\nexport const encodeAsIterable = defaultEncoder.encodeAsIterable\nexport const encodeAsAsyncIterable = defaultEncoder.encodeAsAsyncIterable\nexport { FLOAT32_OPTIONS } from './decode.js'\nimport { FLOAT32_OPTIONS } from './decode.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const THROW_ON_ITERABLE = 2048\n\n\n","import { next as Automerge } from \"@automerge/automerge/slim\";\nimport debug from \"debug\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { generateAutomergeUrl, interpretAsDocumentId, parseAutomergeUrl, } from \"./AutomergeUrl.js\";\nimport { DocHandle } from \"./DocHandle.js\";\nimport { RemoteHeadsSubscriptions } from \"./RemoteHeadsSubscriptions.js\";\nimport { headsAreSame } from \"./helpers/headsAreSame.js\";\nimport { throttle } from \"./helpers/throttle.js\";\nimport { NetworkSubsystem } from \"./network/NetworkSubsystem.js\";\nimport { StorageSubsystem } from \"./storage/StorageSubsystem.js\";\nimport { CollectionSynchronizer } from \"./synchronizer/CollectionSynchronizer.js\";\nfunction randomPeerId() {\n    return (\"peer-\" + Math.random().toString(36).slice(4));\n}\n/** A Repo is a collection of documents with networking, syncing, and storage capabilities. */\n/** The `Repo` is the main entry point of this library\n *\n * @remarks\n * To construct a `Repo` you will need an {@link StorageAdapter} and one or\n * more {@link NetworkAdapter}s. Once you have a `Repo` you can use it to\n * obtain {@link DocHandle}s.\n */\nexport class Repo extends EventEmitter {\n    #log;\n    /** @hidden */\n    networkSubsystem;\n    /** @hidden */\n    storageSubsystem;\n    /** The debounce rate is adjustable on the repo. */\n    /** @hidden */\n    saveDebounceRate = 100;\n    #handleCache = {};\n    /** @hidden */\n    synchronizer;\n    /** By default, we share generously with all peers. */\n    /** @hidden */\n    sharePolicy = async () =\u003e true;\n    /** maps peer id to to persistence information (storageId, isEphemeral), access by collection synchronizer  */\n    /** @hidden */\n    peerMetadataByPeerId = {};\n    #remoteHeadsSubscriptions = new RemoteHeadsSubscriptions();\n    #remoteHeadsGossipingEnabled = false;\n    constructor({ storage, network = [], peerId = randomPeerId(), sharePolicy, isEphemeral = storage === undefined, enableRemoteHeadsGossiping = false, } = {}) {\n        super();\n        this.#remoteHeadsGossipingEnabled = enableRemoteHeadsGossiping;\n        this.#log = debug(`automerge-repo:repo`);\n        this.sharePolicy = sharePolicy ?? this.sharePolicy;\n        this.on(\"delete-document\", ({ documentId }) =\u003e {\n            // TODO Pass the delete on to the network\n            // synchronizer.removeDocument(documentId)\n            if (storageSubsystem) {\n                storageSubsystem.removeDoc(documentId).catch(err =\u003e {\n                    this.#log(\"error deleting document\", { documentId, err });\n                });\n            }\n        });\n        // SYNCHRONIZER\n        // The synchronizer uses the network subsystem to keep documents in sync with peers.\n        this.synchronizer = new CollectionSynchronizer(this);\n        // When the synchronizer emits messages, send them to peers\n        this.synchronizer.on(\"message\", message =\u003e {\n            this.#log(`sending ${message.type} message to ${message.targetId}`);\n            networkSubsystem.send(message);\n        });\n        if (this.#remoteHeadsGossipingEnabled) {\n            this.synchronizer.on(\"open-doc\", ({ peerId, documentId }) =\u003e {\n                this.#remoteHeadsSubscriptions.subscribePeerToDoc(peerId, documentId);\n            });\n        }\n        // STORAGE\n        // The storage subsystem has access to some form of persistence, and deals with save and loading documents.\n        const storageSubsystem = storage ? new StorageSubsystem(storage) : undefined;\n        this.storageSubsystem = storageSubsystem;\n        // NETWORK\n        // The network subsystem deals with sending and receiving messages to and from peers.\n        const myPeerMetadata = (async () =\u003e ({\n            storageId: await storageSubsystem?.id(),\n            isEphemeral,\n        }))();\n        const networkSubsystem = new NetworkSubsystem(network, peerId, myPeerMetadata);\n        this.networkSubsystem = networkSubsystem;\n        // When we get a new peer, register it with the synchronizer\n        networkSubsystem.on(\"peer\", async ({ peerId, peerMetadata }) =\u003e {\n            this.#log(\"peer connected\", { peerId });\n            if (peerMetadata) {\n                this.peerMetadataByPeerId[peerId] = { ...peerMetadata };\n            }\n            this.sharePolicy(peerId)\n                .then(shouldShare =\u003e {\n                if (shouldShare \u0026\u0026 this.#remoteHeadsGossipingEnabled) {\n                    this.#remoteHeadsSubscriptions.addGenerousPeer(peerId);\n                }\n            })\n                .catch(err =\u003e {\n                console.log(\"error in share policy\", { err });\n            });\n            this.synchronizer.addPeer(peerId);\n        });\n        // When a peer disconnects, remove it from the synchronizer\n        networkSubsystem.on(\"peer-disconnected\", ({ peerId }) =\u003e {\n            this.synchronizer.removePeer(peerId);\n            this.#remoteHeadsSubscriptions.removePeer(peerId);\n        });\n        // Handle incoming messages\n        networkSubsystem.on(\"message\", async (msg) =\u003e {\n            this.#receiveMessage(msg);\n        });\n        this.synchronizer.on(\"sync-state\", message =\u003e {\n            this.#saveSyncState(message);\n            const handle = this.#handleCache[message.documentId];\n            const { storageId } = this.peerMetadataByPeerId[message.peerId] || {};\n            if (!storageId) {\n                return;\n            }\n            const heads = handle.getRemoteHeads(storageId);\n            const haveHeadsChanged = message.syncState.theirHeads \u0026\u0026\n                (!heads || !headsAreSame(heads, message.syncState.theirHeads));\n            if (haveHeadsChanged \u0026\u0026 message.syncState.theirHeads) {\n                handle.setRemoteHeads(storageId, message.syncState.theirHeads);\n                if (storageId \u0026\u0026 this.#remoteHeadsGossipingEnabled) {\n                    this.#remoteHeadsSubscriptions.handleImmediateRemoteHeadsChanged(message.documentId, storageId, message.syncState.theirHeads);\n                }\n            }\n        });\n        if (this.#remoteHeadsGossipingEnabled) {\n            this.#remoteHeadsSubscriptions.on(\"notify-remote-heads\", message =\u003e {\n                this.networkSubsystem.send({\n                    type: \"remote-heads-changed\",\n                    targetId: message.targetId,\n                    documentId: message.documentId,\n                    newHeads: {\n                        [message.storageId]: {\n                            heads: message.heads,\n                            timestamp: message.timestamp,\n                        },\n                    },\n                });\n            });\n            this.#remoteHeadsSubscriptions.on(\"change-remote-subs\", message =\u003e {\n                this.#log(\"change-remote-subs\", message);\n                for (const peer of message.peers) {\n                    this.networkSubsystem.send({\n                        type: \"remote-subscription-change\",\n                        targetId: peer,\n                        add: message.add,\n                        remove: message.remove,\n                    });\n                }\n            });\n            this.#remoteHeadsSubscriptions.on(\"remote-heads-changed\", message =\u003e {\n                const handle = this.#handleCache[message.documentId];\n                handle.setRemoteHeads(message.storageId, message.remoteHeads);\n            });\n        }\n    }\n    // The `document` event is fired by the DocCollection any time we create a new document or look\n    // up a document by ID. We listen for it in order to wire up storage and network synchronization.\n    #registerHandleWithSubsystems(handle) {\n        const { storageSubsystem } = this;\n        if (storageSubsystem) {\n            // Save when the document changes, but no more often than saveDebounceRate.\n            const saveFn = ({ handle, doc }) =\u003e {\n                void storageSubsystem.saveDoc(handle.documentId, doc);\n            };\n            handle.on(\"heads-changed\", throttle(saveFn, this.saveDebounceRate));\n        }\n        handle.on(\"unavailable\", () =\u003e {\n            this.#log(\"document unavailable\", { documentId: handle.documentId });\n            this.emit(\"unavailable-document\", {\n                documentId: handle.documentId,\n            });\n        });\n        // Register the document with the synchronizer. This advertises our interest in the document.\n        this.synchronizer.addDocument(handle.documentId);\n        // Preserve the old event in case anyone was using it.\n        this.emit(\"document\", { handle });\n    }\n    #receiveMessage(message) {\n        switch (message.type) {\n            case \"remote-subscription-change\":\n                if (this.#remoteHeadsGossipingEnabled) {\n                    this.#remoteHeadsSubscriptions.handleControlMessage(message);\n                }\n                break;\n            case \"remote-heads-changed\":\n                if (this.#remoteHeadsGossipingEnabled) {\n                    this.#remoteHeadsSubscriptions.handleRemoteHeads(message);\n                }\n                break;\n            case \"sync\":\n            case \"request\":\n            case \"ephemeral\":\n            case \"doc-unavailable\":\n                this.synchronizer.receiveMessage(message).catch(err =\u003e {\n                    console.log(\"error receiving message\", { err });\n                });\n        }\n    }\n    #throttledSaveSyncStateHandlers = {};\n    /** saves sync state throttled per storage id, if a peer doesn't have a storage id it's sync state is not persisted */\n    #saveSyncState(payload) {\n        if (!this.storageSubsystem) {\n            return;\n        }\n        const { storageId, isEphemeral } = this.peerMetadataByPeerId[payload.peerId] || {};\n        if (!storageId || isEphemeral) {\n            return;\n        }\n        let handler = this.#throttledSaveSyncStateHandlers[storageId];\n        if (!handler) {\n            handler = this.#throttledSaveSyncStateHandlers[storageId] = throttle(({ documentId, syncState }) =\u003e {\n                void this.storageSubsystem.saveSyncState(documentId, storageId, syncState);\n            }, this.saveDebounceRate);\n        }\n        handler(payload);\n    }\n    /** Returns an existing handle if we have it; creates one otherwise. */\n    #getHandle({ documentId, }) {\n        // If we have the handle cached, return it\n        if (this.#handleCache[documentId])\n            return this.#handleCache[documentId];\n        // If not, create a new handle, cache it, and return it\n        if (!documentId)\n            throw new Error(`Invalid documentId ${documentId}`);\n        const handle = new DocHandle(documentId);\n        this.#handleCache[documentId] = handle;\n        return handle;\n    }\n    /** Returns all the handles we have cached. */\n    get handles() {\n        return this.#handleCache;\n    }\n    /** Returns a list of all connected peer ids */\n    get peers() {\n        return this.synchronizer.peers;\n    }\n    getStorageIdOfPeer(peerId) {\n        return this.peerMetadataByPeerId[peerId]?.storageId;\n    }\n    /**\n     * Creates a new document and returns a handle to it. The initial value of the document is an\n     * empty object `{}` unless an initial value is provided. Its documentId is generated by the\n     * system. we emit a `document` event to advertise interest in the document.\n     */\n    create(initialValue) {\n        // Generate a new UUID and store it in the buffer\n        const { documentId } = parseAutomergeUrl(generateAutomergeUrl());\n        const handle = this.#getHandle({\n            documentId,\n        });\n        this.#registerHandleWithSubsystems(handle);\n        handle.update(() =\u003e {\n            let nextDoc;\n            if (initialValue) {\n                nextDoc = Automerge.from(initialValue);\n            }\n            else {\n                nextDoc = Automerge.emptyChange(Automerge.init());\n            }\n            return nextDoc;\n        });\n        handle.doneLoading();\n        return handle;\n    }\n    /** Create a new DocHandle by cloning the history of an existing DocHandle.\n     *\n     * @param clonedHandle - The handle to clone\n     *\n     * @remarks This is a wrapper around the `clone` function in the Automerge library.\n     * The new `DocHandle` will have a new URL but will share history with the original,\n     * which means that changes made to the cloned handle can be sensibly merged back\n     * into the original.\n     *\n     * Any peers this `Repo` is connected to for whom `sharePolicy` returns `true` will\n     * be notified of the newly created DocHandle.\n     *\n     * @throws if the cloned handle is not yet ready or if\n     * `clonedHandle.docSync()` returns `undefined` (i.e. the handle is unavailable).\n     */\n    clone(clonedHandle) {\n        if (!clonedHandle.isReady()) {\n            throw new Error(`Cloned handle is not yet in ready state.\n        (Try await handle.whenReady() first.)`);\n        }\n        const sourceDoc = clonedHandle.docSync();\n        if (!sourceDoc) {\n            throw new Error(\"Cloned handle doesn't have a document.\");\n        }\n        const handle = this.create();\n        handle.update(() =\u003e {\n            // we replace the document with the new cloned one\n            return Automerge.clone(sourceDoc);\n        });\n        return handle;\n    }\n    /**\n     * Retrieves a document by id. It gets data from the local system, but also emits a `document`\n     * event to advertise interest in the document.\n     */\n    find(\n    /** The url or documentId of the handle to retrieve */\n    id) {\n        const documentId = interpretAsDocumentId(id);\n        // If we have the handle cached, return it\n        if (this.#handleCache[documentId]) {\n            if (this.#handleCache[documentId].isUnavailable()) {\n                // this ensures that the event fires after the handle has been returned\n                setTimeout(() =\u003e {\n                    this.#handleCache[documentId].emit(\"unavailable\", {\n                        handle: this.#handleCache[documentId],\n                    });\n                });\n            }\n            return this.#handleCache[documentId];\n        }\n        // If we don't already have the handle, make an empty one and try loading it\n        const handle = this.#getHandle({\n            documentId,\n        });\n        // Loading \u0026 network is going to be asynchronous no matter what,\n        // but we want to return the handle immediately.\n        const attemptLoad = this.storageSubsystem\n            ? this.storageSubsystem.loadDoc(handle.documentId)\n            : Promise.resolve(null);\n        attemptLoad\n            .then(async (loadedDoc) =\u003e {\n            if (loadedDoc) {\n                // uhhhh, sorry if you're reading this because we were lying to the type system\n                handle.update(() =\u003e loadedDoc);\n                handle.doneLoading();\n            }\n            else {\n                // we want to wait for the network subsystem to be ready before\n                // we request the document. this prevents entering unavailable during initialization.\n                await this.networkSubsystem.whenReady();\n                handle.request();\n            }\n            this.#registerHandleWithSubsystems(handle);\n        })\n            .catch(err =\u003e {\n            this.#log(\"error waiting for network\", { err });\n        });\n        return handle;\n    }\n    delete(\n    /** The url or documentId of the handle to delete */\n    id) {\n        const documentId = interpretAsDocumentId(id);\n        const handle = this.#getHandle({ documentId });\n        handle.delete();\n        delete this.#handleCache[documentId];\n        this.emit(\"delete-document\", { documentId });\n    }\n    /**\n     * Exports a document to a binary format.\n     * @param id - The url or documentId of the handle to export\n     *\n     * @returns Promise\u003cUint8Array | undefined\u003e - A Promise containing the binary document,\n     * or undefined if the document is unavailable.\n     */\n    async export(id) {\n        const documentId = interpretAsDocumentId(id);\n        const handle = this.#getHandle({ documentId });\n        const doc = await handle.doc();\n        if (!doc)\n            return undefined;\n        return Automerge.save(doc);\n    }\n    /**\n     * Imports document binary into the repo.\n     * @param binary - The binary to import\n     */\n    import(binary) {\n        const doc = Automerge.load(binary);\n        const handle = this.create();\n        handle.update(() =\u003e {\n            return Automerge.clone(doc);\n        });\n        return handle;\n    }\n    subscribeToRemotes = (remotes) =\u003e {\n        if (this.#remoteHeadsGossipingEnabled) {\n            this.#log(\"subscribeToRemotes\", { remotes });\n            this.#remoteHeadsSubscriptions.subscribeToRemotes(remotes);\n        }\n        else {\n            this.#log(\"WARN: subscribeToRemotes called but remote heads gossiping is not enabled\");\n        }\n    };\n    storageId = async () =\u003e {\n        if (!this.storageSubsystem) {\n            return undefined;\n        }\n        else {\n            return this.storageSubsystem.id();\n        }\n    };\n    /**\n     * Writes Documents to a disk.\n     * @hidden this API is experimental and may change.\n     * @param documents - if provided, only writes the specified documents.\n     * @returns Promise\u003cvoid\u003e\n     */\n    async flush(documents) {\n        if (!this.storageSubsystem) {\n            return;\n        }\n        const handles = documents\n            ? documents.map(id =\u003e this.#handleCache[id])\n            : Object.values(this.#handleCache);\n        await Promise.all(handles.map(async (handle) =\u003e {\n            const doc = handle.docSync();\n            if (!doc) {\n                return;\n            }\n            return this.storageSubsystem.saveDoc(handle.documentId, doc);\n        }));\n    }\n    shutdown() {\n        this.networkSubsystem.adapters.forEach(adapter =\u003e {\n            adapter.disconnect();\n        });\n        return this.flush();\n    }\n    metrics() {\n        return { documents: this.synchronizer.metrics() };\n    }\n}\n","import { EventEmitter } from \"eventemitter3\";\nimport debug from \"debug\";\nexport class RemoteHeadsSubscriptions extends EventEmitter {\n    // Storage IDs we have received remote heads from\n    #knownHeads = new Map();\n    // Storage IDs we have subscribed to via Repo.subscribeToRemoteHeads\n    #ourSubscriptions = new Set();\n    // Storage IDs other peers have subscribed to by sending us a control message\n    #theirSubscriptions = new Map();\n    // Peers we will always share remote heads with even if they are not subscribed\n    #generousPeers = new Set();\n    // Documents each peer has open, we need this information so we only send remote heads of documents that the peer knows\n    #subscribedDocsByPeer = new Map();\n    #log = debug(\"automerge-repo:remote-heads-subscriptions\");\n    subscribeToRemotes(remotes) {\n        this.#log(\"subscribeToRemotes\", remotes);\n        const remotesToAdd = [];\n        for (const remote of remotes) {\n            if (!this.#ourSubscriptions.has(remote)) {\n                this.#ourSubscriptions.add(remote);\n                remotesToAdd.push(remote);\n            }\n        }\n        if (remotesToAdd.length \u003e 0) {\n            this.emit(\"change-remote-subs\", {\n                add: remotesToAdd,\n                peers: Array.from(this.#generousPeers),\n            });\n        }\n    }\n    unsubscribeFromRemotes(remotes) {\n        this.#log(\"subscribeToRemotes\", remotes);\n        const remotesToRemove = [];\n        for (const remote of remotes) {\n            if (this.#ourSubscriptions.has(remote)) {\n                this.#ourSubscriptions.delete(remote);\n                if (!this.#theirSubscriptions.has(remote)) {\n                    remotesToRemove.push(remote);\n                }\n            }\n        }\n        if (remotesToRemove.length \u003e 0) {\n            this.emit(\"change-remote-subs\", {\n                remove: remotesToRemove,\n                peers: Array.from(this.#generousPeers),\n            });\n        }\n    }\n    handleControlMessage(control) {\n        const remotesToAdd = [];\n        const remotesToRemove = [];\n        const addedRemotesWeKnow = [];\n        this.#log(\"handleControlMessage\", control);\n        if (control.add) {\n            for (const remote of control.add) {\n                let theirSubs = this.#theirSubscriptions.get(remote);\n                if (this.#ourSubscriptions.has(remote) || theirSubs) {\n                    addedRemotesWeKnow.push(remote);\n                }\n                if (!theirSubs) {\n                    theirSubs = new Set();\n                    this.#theirSubscriptions.set(remote, theirSubs);\n                    if (!this.#ourSubscriptions.has(remote)) {\n                        remotesToAdd.push(remote);\n                    }\n                }\n                theirSubs.add(control.senderId);\n            }\n        }\n        if (control.remove) {\n            for (const remote of control.remove) {\n                const theirSubs = this.#theirSubscriptions.get(remote);\n                if (theirSubs) {\n                    theirSubs.delete(control.senderId);\n                    // if no one is subscribed anymore remove remote\n                    if (theirSubs.size == 0 \u0026\u0026 !this.#ourSubscriptions.has(remote)) {\n                        remotesToRemove.push(remote);\n                    }\n                }\n            }\n        }\n        if (remotesToAdd.length \u003e 0 || remotesToRemove.length \u003e 0) {\n            this.emit(\"change-remote-subs\", {\n                peers: Array.from(this.#generousPeers),\n                add: remotesToAdd,\n                remove: remotesToRemove,\n            });\n        }\n        // send all our stored heads of documents the peer knows for the remotes they've added\n        for (const remote of addedRemotesWeKnow) {\n            const subscribedDocs = this.#subscribedDocsByPeer.get(control.senderId);\n            if (subscribedDocs) {\n                for (const documentId of subscribedDocs) {\n                    const knownHeads = this.#knownHeads.get(documentId);\n                    if (!knownHeads) {\n                        continue;\n                    }\n                    const lastHeads = knownHeads.get(remote);\n                    if (lastHeads) {\n                        this.emit(\"notify-remote-heads\", {\n                            targetId: control.senderId,\n                            documentId,\n                            heads: lastHeads.heads,\n                            timestamp: lastHeads.timestamp,\n                            storageId: remote,\n                        });\n                    }\n                }\n            }\n        }\n    }\n    /** A peer we are not directly connected to has changed their heads */\n    handleRemoteHeads(msg) {\n        this.#log(\"handleRemoteHeads\", msg);\n        const changedHeads = this.#changedHeads(msg);\n        // Emit a remote-heads-changed event to update local dochandles\n        for (const event of changedHeads) {\n            if (this.#ourSubscriptions.has(event.storageId)) {\n                this.emit(\"remote-heads-changed\", event);\n            }\n        }\n        // Notify generous peers of these changes regardless of if they are subscribed to us\n        for (const event of changedHeads) {\n            for (const peer of this.#generousPeers) {\n                // don't emit event to sender if sender is a generous peer\n                if (peer === msg.senderId) {\n                    continue;\n                }\n                this.emit(\"notify-remote-heads\", {\n                    targetId: peer,\n                    documentId: event.documentId,\n                    heads: event.remoteHeads,\n                    timestamp: event.timestamp,\n                    storageId: event.storageId,\n                });\n            }\n        }\n        // Notify subscribers of these changes\n        for (const event of changedHeads) {\n            const theirSubs = this.#theirSubscriptions.get(event.storageId);\n            if (theirSubs) {\n                for (const peerId of theirSubs) {\n                    if (this.#isPeerSubscribedToDoc(peerId, event.documentId)) {\n                        this.emit(\"notify-remote-heads\", {\n                            targetId: peerId,\n                            documentId: event.documentId,\n                            heads: event.remoteHeads,\n                            timestamp: event.timestamp,\n                            storageId: event.storageId,\n                        });\n                    }\n                }\n            }\n        }\n    }\n    /** A peer we are directly connected to has updated their heads */\n    handleImmediateRemoteHeadsChanged(documentId, storageId, heads) {\n        this.#log(\"handleLocalHeadsChanged\", documentId, storageId, heads);\n        const remote = this.#knownHeads.get(documentId);\n        const timestamp = Date.now();\n        if (!remote) {\n            this.#knownHeads.set(documentId, new Map([[storageId, { heads, timestamp }]]));\n        }\n        else {\n            const docRemote = remote.get(storageId);\n            if (!docRemote || docRemote.timestamp \u003c Date.now()) {\n                remote.set(storageId, { heads, timestamp: Date.now() });\n            }\n        }\n        const theirSubs = this.#theirSubscriptions.get(storageId);\n        if (theirSubs) {\n            for (const peerId of theirSubs) {\n                if (this.#isPeerSubscribedToDoc(peerId, documentId)) {\n                    this.emit(\"notify-remote-heads\", {\n                        targetId: peerId,\n                        documentId: documentId,\n                        heads: heads,\n                        timestamp: timestamp,\n                        storageId: storageId,\n                    });\n                }\n            }\n        }\n    }\n    addGenerousPeer(peerId) {\n        this.#log(\"addGenerousPeer\", peerId);\n        this.#generousPeers.add(peerId);\n        if (this.#ourSubscriptions.size \u003e 0) {\n            this.emit(\"change-remote-subs\", {\n                add: Array.from(this.#ourSubscriptions),\n                peers: [peerId],\n            });\n        }\n        for (const [documentId, remote] of this.#knownHeads) {\n            for (const [storageId, { heads, timestamp }] of remote) {\n                this.emit(\"notify-remote-heads\", {\n                    targetId: peerId,\n                    documentId: documentId,\n                    heads: heads,\n                    timestamp: timestamp,\n                    storageId: storageId,\n                });\n            }\n        }\n    }\n    removePeer(peerId) {\n        this.#log(\"removePeer\", peerId);\n        const remotesToRemove = [];\n        this.#generousPeers.delete(peerId);\n        this.#subscribedDocsByPeer.delete(peerId);\n        for (const [storageId, peerIds] of this.#theirSubscriptions) {\n            if (peerIds.has(peerId)) {\n                peerIds.delete(peerId);\n                if (peerIds.size == 0) {\n                    remotesToRemove.push(storageId);\n                    this.#theirSubscriptions.delete(storageId);\n                }\n            }\n        }\n        if (remotesToRemove.length \u003e 0) {\n            this.emit(\"change-remote-subs\", {\n                remove: remotesToRemove,\n                peers: Array.from(this.#generousPeers),\n            });\n        }\n    }\n    subscribePeerToDoc(peerId, documentId) {\n        let subscribedDocs = this.#subscribedDocsByPeer.get(peerId);\n        if (!subscribedDocs) {\n            subscribedDocs = new Set();\n            this.#subscribedDocsByPeer.set(peerId, subscribedDocs);\n        }\n        subscribedDocs.add(documentId);\n        const remoteHeads = this.#knownHeads.get(documentId);\n        if (remoteHeads) {\n            for (const [storageId, lastHeads] of remoteHeads) {\n                const subscribedPeers = this.#theirSubscriptions.get(storageId);\n                if (subscribedPeers \u0026\u0026 subscribedPeers.has(peerId)) {\n                    this.emit(\"notify-remote-heads\", {\n                        targetId: peerId,\n                        documentId,\n                        heads: lastHeads.heads,\n                        timestamp: lastHeads.timestamp,\n                        storageId,\n                    });\n                }\n            }\n        }\n    }\n    #isPeerSubscribedToDoc(peerId, documentId) {\n        const subscribedDocs = this.#subscribedDocsByPeer.get(peerId);\n        return subscribedDocs \u0026\u0026 subscribedDocs.has(documentId);\n    }\n    /** Returns the (document, storageId) pairs which have changed after processing msg */\n    #changedHeads(msg) {\n        const changedHeads = [];\n        const { documentId, newHeads } = msg;\n        for (const [storageId, { heads, timestamp }] of Object.entries(newHeads)) {\n            if (!this.#ourSubscriptions.has(storageId) \u0026\u0026\n                !this.#theirSubscriptions.has(storageId)) {\n                continue;\n            }\n            let remote = this.#knownHeads.get(documentId);\n            if (!remote) {\n                remote = new Map();\n                this.#knownHeads.set(documentId, remote);\n            }\n            const docRemote = remote.get(storageId);\n            if (docRemote \u0026\u0026 docRemote.timestamp \u003e= timestamp) {\n                continue;\n            }\n            else {\n                remote.set(storageId, { timestamp, heads });\n                changedHeads.push({\n                    documentId,\n                    storageId: storageId,\n                    remoteHeads: heads,\n                    timestamp,\n                });\n            }\n        }\n        return changedHeads;\n    }\n}\n","import debug from \"debug\";\nimport { EventEmitter } from \"eventemitter3\";\nimport { isEphemeralMessage, isRepoMessage, } from \"./messages.js\";\nconst getEphemeralMessageSource = (message) =\u003e `${message.senderId}:${message.sessionId}`;\nexport class NetworkSubsystem extends EventEmitter {\n    peerId;\n    peerMetadata;\n    #log;\n    #adaptersByPeer = {};\n    #count = 0;\n    #sessionId = Math.random().toString(36).slice(2);\n    #ephemeralSessionCounts = {};\n    adapters = [];\n    constructor(adapters, peerId, peerMetadata) {\n        super();\n        this.peerId = peerId;\n        this.peerMetadata = peerMetadata;\n        this.#log = debug(`automerge-repo:network:${this.peerId}`);\n        adapters.forEach(a =\u003e this.addNetworkAdapter(a));\n    }\n    disconnect() {\n        this.adapters.forEach(a =\u003e a.disconnect());\n    }\n    reconnect() {\n        this.adapters.forEach(a =\u003e a.connect(this.peerId));\n    }\n    addNetworkAdapter(networkAdapter) {\n        this.adapters.push(networkAdapter);\n        networkAdapter.on(\"peer-candidate\", ({ peerId, peerMetadata }) =\u003e {\n            this.#log(`peer candidate: ${peerId} `);\n            // TODO: This is where authentication would happen\n            // TODO: on reconnection, this would create problems!\n            // the server would see a reconnection as a late-arriving channel\n            // for an existing peer and decide to ignore it until the connection\n            // times out: turns out my ICE/SIP emulation laziness did not pay off here\n            if (!this.#adaptersByPeer[peerId]) {\n                // TODO: handle losing a server here\n                this.#adaptersByPeer[peerId] = networkAdapter;\n            }\n            this.emit(\"peer\", { peerId, peerMetadata });\n        });\n        networkAdapter.on(\"peer-disconnected\", ({ peerId }) =\u003e {\n            this.#log(`peer disconnected: ${peerId} `);\n            delete this.#adaptersByPeer[peerId];\n            this.emit(\"peer-disconnected\", { peerId });\n        });\n        networkAdapter.on(\"message\", msg =\u003e {\n            if (!isRepoMessage(msg)) {\n                this.#log(`invalid message: ${JSON.stringify(msg)}`);\n                return;\n            }\n            this.#log(`message from ${msg.senderId}`);\n            if (isEphemeralMessage(msg)) {\n                const source = getEphemeralMessageSource(msg);\n                if (this.#ephemeralSessionCounts[source] === undefined ||\n                    msg.count \u003e this.#ephemeralSessionCounts[source]) {\n                    this.#ephemeralSessionCounts[source] = msg.count;\n                    this.emit(\"message\", msg);\n                }\n                return;\n            }\n            this.emit(\"message\", msg);\n        });\n        networkAdapter.on(\"close\", () =\u003e {\n            this.#log(\"adapter closed\");\n            Object.entries(this.#adaptersByPeer).forEach(([peerId, other]) =\u003e {\n                if (other === networkAdapter) {\n                    delete this.#adaptersByPeer[peerId];\n                }\n            });\n        });\n        this.peerMetadata\n            .then(peerMetadata =\u003e {\n            networkAdapter.connect(this.peerId, peerMetadata);\n        })\n            .catch(err =\u003e {\n            this.#log(\"error connecting to network\", err);\n        });\n    }\n    // TODO: this probably introduces a race condition for the ready event\n    // but I plan to refactor that as part of this branch in another patch\n    removeNetworkAdapter(networkAdapter) {\n        this.adapters = this.adapters.filter(a =\u003e a !== networkAdapter);\n        networkAdapter.disconnect();\n    }\n    send(message) {\n        const peer = this.#adaptersByPeer[message.targetId];\n        if (!peer) {\n            this.#log(`Tried to send message but peer not found: ${message.targetId}`);\n            return;\n        }\n        /** Messages come in without a senderId and other required information; this is where we make\n         * sure they have everything they need.\n         */\n        const prepareMessage = (message) =\u003e {\n            if (message.type === \"ephemeral\") {\n                if (\"count\" in message) {\n                    // existing ephemeral message from another peer; pass on without changes\n                    return message;\n                }\n                else {\n                    // new ephemeral message from us; add our senderId as well as a counter and session id\n                    return {\n                        ...message,\n                        count: ++this.#count,\n                        sessionId: this.#sessionId,\n                        senderId: this.peerId,\n                    };\n                }\n            }\n            else {\n                // other message type; just add our senderId\n                return {\n                    ...message,\n                    senderId: this.peerId,\n                };\n            }\n        };\n        const outbound = prepareMessage(message);\n        this.#log(\"sending message %o\", outbound);\n        peer.send(outbound);\n    }\n    isReady = () =\u003e {\n        return this.adapters.every(a =\u003e a.isReady());\n    };\n    whenReady = async () =\u003e {\n        return Promise.all(this.adapters.map(a =\u003e a.whenReady()));\n    };\n}\n","import * as A from \"@automerge/automerge/slim/next\";\nimport debug from \"debug\";\nimport { headsAreSame } from \"../helpers/headsAreSame.js\";\nimport { mergeArrays } from \"../helpers/mergeArrays.js\";\nimport { keyHash, headsHash } from \"./keyHash.js\";\nimport { chunkTypeFromKey } from \"./chunkTypeFromKey.js\";\nimport * as Uuid from \"uuid\";\n/**\n * The storage subsystem is responsible for saving and loading Automerge documents to and from\n * storage adapter. It also provides a generic key/value storage interface for other uses.\n */\nexport class StorageSubsystem {\n    /** The storage adapter to use for saving and loading documents */\n    #storageAdapter;\n    /** Record of the latest heads we've loaded or saved for each document  */\n    #storedHeads = new Map();\n    /** Metadata on the chunks we've already loaded for each document */\n    #chunkInfos = new Map();\n    /** Flag to avoid compacting when a compaction is already underway */\n    #compacting = false;\n    #log = debug(`automerge-repo:storage-subsystem`);\n    constructor(storageAdapter) {\n        this.#storageAdapter = storageAdapter;\n    }\n    async id() {\n        const storedId = await this.#storageAdapter.load([\"storage-adapter-id\"]);\n        let id;\n        if (storedId) {\n            id = new TextDecoder().decode(storedId);\n        }\n        else {\n            id = Uuid.v4();\n            await this.#storageAdapter.save([\"storage-adapter-id\"], new TextEncoder().encode(id));\n        }\n        return id;\n    }\n    // ARBITRARY KEY/VALUE STORAGE\n    // The `load`, `save`, and `remove` methods are for generic key/value storage, as opposed to\n    // Automerge documents. For example, they're used by the LocalFirstAuthProvider to persist the\n    // encrypted team graph that encodes group membership and permissions.\n    //\n    // The namespace parameter is to prevent collisions with other users of the storage subsystem.\n    // Typically this will be the name of the plug-in, adapter, or other system that is using it. For\n    // example, the LocalFirstAuthProvider uses the namespace `LocalFirstAuthProvider`.\n    /** Loads a value from storage. */\n    async load(\n    /** Namespace to prevent collisions with other users of the storage subsystem. */\n    namespace, \n    /** Key to load. Typically a UUID or other unique identifier, but could be any string. */\n    key) {\n        const storageKey = [namespace, key];\n        return await this.#storageAdapter.load(storageKey);\n    }\n    /** Saves a value in storage. */\n    async save(\n    /** Namespace to prevent collisions with other users of the storage subsystem. */\n    namespace, \n    /** Key to load. Typically a UUID or other unique identifier, but could be any string. */\n    key, \n    /** Data to save, as a binary blob. */\n    data) {\n        const storageKey = [namespace, key];\n        await this.#storageAdapter.save(storageKey, data);\n    }\n    /** Removes a value from storage. */\n    async remove(\n    /** Namespace to prevent collisions with other users of the storage subsystem. */\n    namespace, \n    /** Key to remove. Typically a UUID or other unique identifier, but could be any string. */\n    key) {\n        const storageKey = [namespace, key];\n        await this.#storageAdapter.remove(storageKey);\n    }\n    // AUTOMERGE DOCUMENT STORAGE\n    /**\n     * Loads the Automerge document with the given ID from storage.\n     */\n    async loadDoc(documentId) {\n        // Load all the chunks for this document\n        const chunks = await this.#storageAdapter.loadRange([documentId]);\n        const binaries = [];\n        const chunkInfos = [];\n        for (const chunk of chunks) {\n            // chunks might have been deleted in the interim\n            if (chunk.data === undefined)\n                continue;\n            const chunkType = chunkTypeFromKey(chunk.key);\n            if (chunkType == null)\n                continue;\n            chunkInfos.push({\n                key: chunk.key,\n                type: chunkType,\n                size: chunk.data.length,\n            });\n            binaries.push(chunk.data);\n        }\n        this.#chunkInfos.set(documentId, chunkInfos);\n        // Merge the chunks into a single binary\n        const binary = mergeArrays(binaries);\n        if (binary.length === 0)\n            return null;\n        // Load into an Automerge document\n        const newDoc = A.loadIncremental(A.init(), binary);\n        // Record the latest heads for the document\n        this.#storedHeads.set(documentId, A.getHeads(newDoc));\n        return newDoc;\n    }\n    /**\n     * Saves the provided Automerge document to storage.\n     *\n     * @remarks\n     * Under the hood this makes incremental saves until the incremental size is greater than the\n     * snapshot size, at which point the document is compacted into a single snapshot.\n     */\n    async saveDoc(documentId, doc) {\n        // Don't bother saving if the document hasn't changed\n        if (!this.#shouldSave(documentId, doc))\n            return;\n        const sourceChunks = this.#chunkInfos.get(documentId) ?? [];\n        if (this.#shouldCompact(sourceChunks)) {\n            await this.#saveTotal(documentId, doc, sourceChunks);\n        }\n        else {\n            await this.#saveIncremental(documentId, doc);\n        }\n        this.#storedHeads.set(documentId, A.getHeads(doc));\n    }\n    /**\n     * Removes the Automerge document with the given ID from storage\n     */\n    async removeDoc(documentId) {\n        await this.#storageAdapter.removeRange([documentId, \"snapshot\"]);\n        await this.#storageAdapter.removeRange([documentId, \"incremental\"]);\n        await this.#storageAdapter.removeRange([documentId, \"sync-state\"]);\n    }\n    /**\n     * Saves just the incremental changes since the last save.\n     */\n    async #saveIncremental(documentId, doc) {\n        const binary = A.saveSince(doc, this.#storedHeads.get(documentId) ?? []);\n        if (binary \u0026\u0026 binary.length \u003e 0) {\n            const key = [documentId, \"incremental\", keyHash(binary)];\n            this.#log(`Saving incremental ${key} for document ${documentId}`);\n            await this.#storageAdapter.save(key, binary);\n            if (!this.#chunkInfos.has(documentId)) {\n                this.#chunkInfos.set(documentId, []);\n            }\n            this.#chunkInfos.get(documentId).push({\n                key,\n                type: \"incremental\",\n                size: binary.length,\n            });\n            this.#storedHeads.set(documentId, A.getHeads(doc));\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n    /**\n     * Compacts the document storage into a single shapshot.\n     */\n    async #saveTotal(documentId, doc, sourceChunks) {\n        this.#compacting = true;\n        const binary = A.save(doc);\n        const snapshotHash = headsHash(A.getHeads(doc));\n        const key = [documentId, \"snapshot\", snapshotHash];\n        const oldKeys = new Set(sourceChunks.map(c =\u003e c.key).filter(k =\u003e k[2] !== snapshotHash));\n        this.#log(`Saving snapshot ${key} for document ${documentId}`);\n        this.#log(`deleting old chunks ${Array.from(oldKeys)}`);\n        await this.#storageAdapter.save(key, binary);\n        for (const key of oldKeys) {\n            await this.#storageAdapter.remove(key);\n        }\n        const newChunkInfos = this.#chunkInfos.get(documentId)?.filter(c =\u003e !oldKeys.has(c.key)) ?? [];\n        newChunkInfos.push({ key, type: \"snapshot\", size: binary.length });\n        this.#chunkInfos.set(documentId, newChunkInfos);\n        this.#compacting = false;\n    }\n    async loadSyncState(documentId, storageId) {\n        const key = [documentId, \"sync-state\", storageId];\n        try {\n            const loaded = await this.#storageAdapter.load(key);\n            return loaded ? A.decodeSyncState(loaded) : undefined;\n        }\n        catch (e) {\n            this.#log(`Error loading sync state for ${documentId} from ${storageId}`);\n            return undefined;\n        }\n    }\n    async saveSyncState(documentId, storageId, syncState) {\n        const key = [documentId, \"sync-state\", storageId];\n        await this.#storageAdapter.save(key, A.encodeSyncState(syncState));\n    }\n    /**\n     * Returns true if the document has changed since the last time it was saved.\n     */\n    #shouldSave(documentId, doc) {\n        const oldHeads = this.#storedHeads.get(documentId);\n        if (!oldHeads) {\n            // we haven't saved this document before\n            return true;\n        }\n        const newHeads = A.getHeads(doc);\n        if (headsAreSame(newHeads, oldHeads)) {\n            // the document hasn't changed\n            return false;\n        }\n        return true; // the document has changed\n    }\n    /**\n     * We only compact if the incremental size is greater than the snapshot size.\n     */\n    #shouldCompact(sourceChunks) {\n        if (this.#compacting)\n            return false;\n        let snapshotSize = 0;\n        let incrementalSize = 0;\n        for (const chunk of sourceChunks) {\n            if (chunk.type === \"snapshot\") {\n                snapshotSize += chunk.size;\n            }\n            else {\n                incrementalSize += chunk.size;\n            }\n        }\n        // if the file is currently small, don't worry, just compact\n        // this might seem a bit arbitrary (1k is arbitrary) but is designed to ensure compaction\n        // for documents with only a single large change on top of an empty (or nearly empty) document\n        // for example: imported NPM modules, images, etc.\n        // if we have even more incrementals (so far) than the snapshot, compact\n        return snapshotSize \u003c 1024 || incrementalSize \u003e= snapshotSize;\n    }\n}\n","import * as sha256 from \"fast-sha256\";\nimport { mergeArrays } from \"../helpers/mergeArrays.js\";\nexport function keyHash(binary) {\n    // calculate hash\n    const hash = sha256.hash(binary);\n    return bufferToHexString(hash);\n}\nexport function headsHash(heads) {\n    const encoder = new TextEncoder();\n    const headsbinary = mergeArrays(heads.map((h) =\u003e encoder.encode(h)));\n    return keyHash(headsbinary);\n}\nfunction bufferToHexString(data) {\n    return Array.from(data, byte =\u003e byte.toString(16).padStart(2, \"0\")).join(\"\");\n}\n","import debug from \"debug\";\nimport { stringifyAutomergeUrl } from \"../AutomergeUrl.js\";\nimport { DocSynchronizer } from \"./DocSynchronizer.js\";\nimport { Synchronizer } from \"./Synchronizer.js\";\nconst log = debug(\"automerge-repo:collectionsync\");\n/** A CollectionSynchronizer is responsible for synchronizing a DocCollection with peers. */\nexport class CollectionSynchronizer extends Synchronizer {\n    repo;\n    /** The set of peers we are connected with */\n    #peers = new Set();\n    /** A map of documentIds to their synchronizers */\n    /** @hidden */\n    docSynchronizers = {};\n    /** Used to determine if the document is know to the Collection and a synchronizer exists or is being set up */\n    #docSetUp = {};\n    constructor(repo) {\n        super();\n        this.repo = repo;\n    }\n    /** Returns a synchronizer for the given document, creating one if it doesn't already exist.  */\n    #fetchDocSynchronizer(documentId) {\n        if (!this.docSynchronizers[documentId]) {\n            const handle = this.repo.find(stringifyAutomergeUrl({ documentId }));\n            this.docSynchronizers[documentId] = this.#initDocSynchronizer(handle);\n        }\n        return this.docSynchronizers[documentId];\n    }\n    /** Creates a new docSynchronizer and sets it up to propagate messages */\n    #initDocSynchronizer(handle) {\n        const docSynchronizer = new DocSynchronizer({\n            handle,\n            onLoadSyncState: async (peerId) =\u003e {\n                if (!this.repo.storageSubsystem) {\n                    return;\n                }\n                const { storageId, isEphemeral } = this.repo.peerMetadataByPeerId[peerId] || {};\n                if (!storageId || isEphemeral) {\n                    return;\n                }\n                return this.repo.storageSubsystem.loadSyncState(handle.documentId, storageId);\n            },\n        });\n        docSynchronizer.on(\"message\", event =\u003e this.emit(\"message\", event));\n        docSynchronizer.on(\"open-doc\", event =\u003e this.emit(\"open-doc\", event));\n        docSynchronizer.on(\"sync-state\", event =\u003e this.emit(\"sync-state\", event));\n        return docSynchronizer;\n    }\n    /** returns an array of peerIds that we share this document generously with */\n    async #documentGenerousPeers(documentId) {\n        const peers = Array.from(this.#peers);\n        const generousPeers = [];\n        for (const peerId of peers) {\n            const okToShare = await this.repo.sharePolicy(peerId, documentId);\n            if (okToShare)\n                generousPeers.push(peerId);\n        }\n        return generousPeers;\n    }\n    // PUBLIC\n    /**\n     * When we receive a sync message for a document we haven't got in memory, we\n     * register it with the repo and start synchronizing\n     */\n    async receiveMessage(message) {\n        log(`onSyncMessage: ${message.senderId}, ${message.documentId}, ${\"data\" in message ? message.data.byteLength + \"bytes\" : \"\"}`);\n        const documentId = message.documentId;\n        if (!documentId) {\n            throw new Error(\"received a message with an invalid documentId\");\n        }\n        this.#docSetUp[documentId] = true;\n        const docSynchronizer = this.#fetchDocSynchronizer(documentId);\n        docSynchronizer.receiveMessage(message);\n        // Initiate sync with any new peers\n        const peers = await this.#documentGenerousPeers(documentId);\n        docSynchronizer.beginSync(peers.filter(peerId =\u003e !docSynchronizer.hasPeer(peerId)));\n    }\n    /**\n     * Starts synchronizing the given document with all peers that we share it generously with.\n     */\n    addDocument(documentId) {\n        // HACK: this is a hack to prevent us from adding the same document twice\n        if (this.#docSetUp[documentId]) {\n            return;\n        }\n        const docSynchronizer = this.#fetchDocSynchronizer(documentId);\n        void this.#documentGenerousPeers(documentId).then(peers =\u003e {\n            docSynchronizer.beginSync(peers);\n        });\n    }\n    // TODO: implement this\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    removeDocument(documentId) {\n        throw new Error(\"not implemented\");\n    }\n    /** Adds a peer and maybe starts synchronizing with them */\n    addPeer(peerId) {\n        log(`adding ${peerId} \u0026 synchronizing with them`);\n        if (this.#peers.has(peerId)) {\n            return;\n        }\n        this.#peers.add(peerId);\n        for (const docSynchronizer of Object.values(this.docSynchronizers)) {\n            const { documentId } = docSynchronizer;\n            void this.repo.sharePolicy(peerId, documentId).then(okToShare =\u003e {\n                if (okToShare)\n                    docSynchronizer.beginSync([peerId]);\n            });\n        }\n    }\n    /** Removes a peer and stops synchronizing with them */\n    removePeer(peerId) {\n        log(`removing peer ${peerId}`);\n        this.#peers.delete(peerId);\n        for (const docSynchronizer of Object.values(this.docSynchronizers)) {\n            docSynchronizer.endSync(peerId);\n        }\n    }\n    /** Returns a list of all connected peer ids */\n    get peers() {\n        return Array.from(this.#peers);\n    }\n    metrics() {\n        return Object.fromEntries(Object.entries(this.docSynchronizers).map(([documentId, synchronizer]) =\u003e {\n            return [documentId, synchronizer.metrics()];\n        }));\n    }\n}\n","import * as A from \"@automerge/automerge/slim/next\";\nimport { decode } from \"cbor-x\";\nimport debug from \"debug\";\nimport { READY, REQUESTING, UNAVAILABLE, } from \"../DocHandle.js\";\nimport { isRequestMessage, } from \"../network/messages.js\";\nimport { Synchronizer } from \"./Synchronizer.js\";\nimport { throttle } from \"../helpers/throttle.js\";\n/**\n * DocSynchronizer takes a handle to an Automerge document, and receives \u0026 dispatches sync messages\n * to bring it inline with all other peers' versions.\n */\nexport class DocSynchronizer extends Synchronizer {\n    #log;\n    syncDebounceRate = 100;\n    /** Active peers */\n    #peers = [];\n    #pendingSyncStateCallbacks = {};\n    #peerDocumentStatuses = {};\n    /** Sync state for each peer we've communicated with (including inactive peers) */\n    #syncStates = {};\n    #pendingSyncMessages = [];\n    #syncStarted = false;\n    #handle;\n    #onLoadSyncState;\n    constructor({ handle, onLoadSyncState }) {\n        super();\n        this.#handle = handle;\n        this.#onLoadSyncState =\n            onLoadSyncState ?? (() =\u003e Promise.resolve(undefined));\n        const docId = handle.documentId.slice(0, 5);\n        this.#log = debug(`automerge-repo:docsync:${docId}`);\n        handle.on(\"change\", throttle(() =\u003e this.#syncWithPeers(), this.syncDebounceRate));\n        handle.on(\"ephemeral-message-outbound\", payload =\u003e this.#broadcastToPeers(payload));\n        // Process pending sync messages immediately after the handle becomes ready.\n        void (async () =\u003e {\n            await handle.doc([READY, REQUESTING]);\n            this.#processAllPendingSyncMessages();\n        })();\n    }\n    get peerStates() {\n        return this.#peerDocumentStatuses;\n    }\n    get documentId() {\n        return this.#handle.documentId;\n    }\n    /// PRIVATE\n    async #syncWithPeers() {\n        this.#log(`syncWithPeers`);\n        const doc = await this.#handle.doc();\n        if (doc === undefined)\n            return;\n        this.#peers.forEach(peerId =\u003e this.#sendSyncMessage(peerId, doc));\n    }\n    async #broadcastToPeers({ data, }) {\n        this.#log(`broadcastToPeers`, this.#peers);\n        this.#peers.forEach(peerId =\u003e this.#sendEphemeralMessage(peerId, data));\n    }\n    #sendEphemeralMessage(peerId, data) {\n        this.#log(`sendEphemeralMessage -\u003e${peerId}`);\n        const message = {\n            type: \"ephemeral\",\n            targetId: peerId,\n            documentId: this.#handle.documentId,\n            data,\n        };\n        this.emit(\"message\", message);\n    }\n    #withSyncState(peerId, callback) {\n        this.#addPeer(peerId);\n        if (!(peerId in this.#peerDocumentStatuses)) {\n            this.#peerDocumentStatuses[peerId] = \"unknown\";\n        }\n        const syncState = this.#syncStates[peerId];\n        if (syncState) {\n            callback(syncState);\n            return;\n        }\n        let pendingCallbacks = this.#pendingSyncStateCallbacks[peerId];\n        if (!pendingCallbacks) {\n            this.#onLoadSyncState(peerId)\n                .then(syncState =\u003e {\n                this.#initSyncState(peerId, syncState ?? A.initSyncState());\n            })\n                .catch(err =\u003e {\n                this.#log(`Error loading sync state for ${peerId}: ${err}`);\n            });\n            pendingCallbacks = this.#pendingSyncStateCallbacks[peerId] = [];\n        }\n        pendingCallbacks.push(callback);\n    }\n    #addPeer(peerId) {\n        if (!this.#peers.includes(peerId)) {\n            this.#peers.push(peerId);\n            this.emit(\"open-doc\", { documentId: this.documentId, peerId });\n        }\n    }\n    #initSyncState(peerId, syncState) {\n        const pendingCallbacks = this.#pendingSyncStateCallbacks[peerId];\n        if (pendingCallbacks) {\n            for (const callback of pendingCallbacks) {\n                callback(syncState);\n            }\n        }\n        delete this.#pendingSyncStateCallbacks[peerId];\n        this.#syncStates[peerId] = syncState;\n    }\n    #setSyncState(peerId, syncState) {\n        this.#syncStates[peerId] = syncState;\n        this.emit(\"sync-state\", {\n            peerId,\n            syncState,\n            documentId: this.#handle.documentId,\n        });\n    }\n    #sendSyncMessage(peerId, doc) {\n        this.#log(`sendSyncMessage -\u003e${peerId}`);\n        this.#withSyncState(peerId, syncState =\u003e {\n            const [newSyncState, message] = A.generateSyncMessage(doc, syncState);\n            if (message) {\n                this.#setSyncState(peerId, newSyncState);\n                const isNew = A.getHeads(doc).length === 0;\n                if (!this.#handle.isReady() \u0026\u0026\n                    isNew \u0026\u0026\n                    newSyncState.sharedHeads.length === 0 \u0026\u0026\n                    !Object.values(this.#peerDocumentStatuses).includes(\"has\") \u0026\u0026\n                    this.#peerDocumentStatuses[peerId] === \"unknown\") {\n                    // we don't have the document (or access to it), so we request it\n                    this.emit(\"message\", {\n                        type: \"request\",\n                        targetId: peerId,\n                        documentId: this.#handle.documentId,\n                        data: message,\n                    });\n                }\n                else {\n                    this.emit(\"message\", {\n                        type: \"sync\",\n                        targetId: peerId,\n                        data: message,\n                        documentId: this.#handle.documentId,\n                    });\n                }\n                // if we have sent heads, then the peer now has or will have the document\n                if (!isNew) {\n                    this.#peerDocumentStatuses[peerId] = \"has\";\n                }\n            }\n        });\n    }\n    /// PUBLIC\n    hasPeer(peerId) {\n        return this.#peers.includes(peerId);\n    }\n    beginSync(peerIds) {\n        const noPeersWithDocument = peerIds.every(peerId =\u003e this.#peerDocumentStatuses[peerId] in [\"unavailable\", \"wants\"]);\n        // At this point if we don't have anything in our storage, we need to use an empty doc to sync\n        // with; but we don't want to surface that state to the front end\n        const docPromise = this.#handle\n            .doc([READY, REQUESTING, UNAVAILABLE])\n            .then(doc =\u003e {\n            // we register out peers first, then say that sync has started\n            this.#syncStarted = true;\n            this.#checkDocUnavailable();\n            const wasUnavailable = doc === undefined;\n            if (wasUnavailable \u0026\u0026 noPeersWithDocument) {\n                return;\n            }\n            // If the doc is unavailable we still need a blank document to generate\n            // the sync message from\n            return doc ?? A.init();\n        });\n        this.#log(`beginSync: ${peerIds.join(\", \")}`);\n        peerIds.forEach(peerId =\u003e {\n            this.#withSyncState(peerId, syncState =\u003e {\n                // HACK: if we have a sync state already, we round-trip it through the encoding system to make\n                // sure state is preserved. This prevents an infinite loop caused by failed attempts to send\n                // messages during disconnection.\n                // TODO: cover that case with a test and remove this hack\n                const reparsedSyncState = A.decodeSyncState(A.encodeSyncState(syncState));\n                this.#setSyncState(peerId, reparsedSyncState);\n                docPromise\n                    .then(doc =\u003e {\n                    if (doc) {\n                        this.#sendSyncMessage(peerId, doc);\n                    }\n                })\n                    .catch(err =\u003e {\n                    this.#log(`Error loading doc for ${peerId}: ${err}`);\n                });\n            });\n        });\n    }\n    endSync(peerId) {\n        this.#log(`removing peer ${peerId}`);\n        this.#peers = this.#peers.filter(p =\u003e p !== peerId);\n    }\n    receiveMessage(message) {\n        switch (message.type) {\n            case \"sync\":\n            case \"request\":\n                this.receiveSyncMessage(message);\n                break;\n            case \"ephemeral\":\n                this.receiveEphemeralMessage(message);\n                break;\n            case \"doc-unavailable\":\n                this.#peerDocumentStatuses[message.senderId] = \"unavailable\";\n                this.#checkDocUnavailable();\n                break;\n            default:\n                throw new Error(`unknown message type: ${message}`);\n        }\n    }\n    receiveEphemeralMessage(message) {\n        if (message.documentId !== this.#handle.documentId)\n            throw new Error(`channelId doesn't match documentId`);\n        const { senderId, data } = message;\n        const contents = decode(new Uint8Array(data));\n        this.#handle.emit(\"ephemeral-message\", {\n            handle: this.#handle,\n            senderId,\n            message: contents,\n        });\n        this.#peers.forEach(peerId =\u003e {\n            if (peerId === senderId)\n                return;\n            this.emit(\"message\", {\n                ...message,\n                targetId: peerId,\n            });\n        });\n    }\n    receiveSyncMessage(message) {\n        if (message.documentId !== this.#handle.documentId)\n            throw new Error(`channelId doesn't match documentId`);\n        // We need to block receiving the syncMessages until we've checked local storage\n        if (!this.#handle.inState([READY, REQUESTING, UNAVAILABLE])) {\n            this.#pendingSyncMessages.push({ message, received: new Date() });\n            return;\n        }\n        this.#processAllPendingSyncMessages();\n        this.#processSyncMessage(message);\n    }\n    #processSyncMessage(message) {\n        if (isRequestMessage(message)) {\n            this.#peerDocumentStatuses[message.senderId] = \"wants\";\n        }\n        this.#checkDocUnavailable();\n        // if the message has heads, then the peer has the document\n        if (A.decodeSyncMessage(message.data).heads.length \u003e 0) {\n            this.#peerDocumentStatuses[message.senderId] = \"has\";\n        }\n        this.#withSyncState(message.senderId, syncState =\u003e {\n            this.#handle.update(doc =\u003e {\n                const [newDoc, newSyncState] = A.receiveSyncMessage(doc, syncState, message.data);\n                this.#setSyncState(message.senderId, newSyncState);\n                // respond to just this peer (as required)\n                this.#sendSyncMessage(message.senderId, doc);\n                return newDoc;\n            });\n            this.#checkDocUnavailable();\n        });\n    }\n    #checkDocUnavailable() {\n        // if we know none of the peers have the document, tell all our peers that we don't either\n        if (this.#syncStarted \u0026\u0026\n            this.#handle.inState([REQUESTING]) \u0026\u0026\n            this.#peers.every(peerId =\u003e this.#peerDocumentStatuses[peerId] === \"unavailable\" ||\n                this.#peerDocumentStatuses[peerId] === \"wants\")) {\n            this.#peers\n                .filter(peerId =\u003e this.#peerDocumentStatuses[peerId] === \"wants\")\n                .forEach(peerId =\u003e {\n                const message = {\n                    type: \"doc-unavailable\",\n                    documentId: this.#handle.documentId,\n                    targetId: peerId,\n                };\n                this.emit(\"message\", message);\n            });\n            this.#handle.unavailable();\n        }\n    }\n    #processAllPendingSyncMessages() {\n        for (const message of this.#pendingSyncMessages) {\n            this.#processSyncMessage(message.message);\n        }\n        this.#pendingSyncMessages = [];\n    }\n    metrics() {\n        return {\n            peers: this.#peers,\n            size: this.#handle.metrics(),\n        };\n    }\n}\n","/* c8 ignore start */\nimport { EventEmitter } from \"eventemitter3\";\n/** An interface representing some way to connect to other peers\n *\n * @remarks\n * The {@link Repo} uses one or more `NetworkAdapter`s to connect to other peers.\n * Because the network may take some time to be ready the {@link Repo} will wait\n * until the adapter emits a `ready` event before it starts trying to use it\n *\n * This utility class can be used as a base to build a custom network adapter. It\n * is most useful as a simple way to add the necessary event emitter functionality\n */\nexport class NetworkAdapter extends EventEmitter {\n    peerId;\n    peerMetadata;\n}\n","// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nexport default ws\n","import { NetworkAdapter, cbor, } from \"@automerge/automerge-repo/slim\";\nimport WebSocket from \"isomorphic-ws\";\nimport debug from \"debug\";\nimport { isErrorMessage, isPeerMessage, } from \"./messages.js\";\nimport { ProtocolV1 } from \"./protocolVersion.js\";\nimport { assert } from \"./assert.js\";\nimport { toArrayBuffer } from \"./toArrayBuffer.js\";\nclass WebSocketNetworkAdapter extends NetworkAdapter {\n    socket;\n}\nexport class BrowserWebSocketClientAdapter extends WebSocketNetworkAdapter {\n    url;\n    retryInterval;\n    #ready = false;\n    #readyResolver;\n    #readyPromise = new Promise(resolve =\u003e {\n        this.#readyResolver = resolve;\n    });\n    isReady() {\n        return this.#ready;\n    }\n    whenReady() {\n        return this.#readyPromise;\n    }\n    #forceReady() {\n        if (!this.#ready) {\n            this.#ready = true;\n            this.#readyResolver?.();\n        }\n    }\n    #retryIntervalId;\n    #log = debug(\"automerge-repo:websocket:browser\");\n    remotePeerId; // this adapter only connects to one remote client at a time\n    constructor(url, retryInterval = 5000) {\n        super();\n        this.url = url;\n        this.retryInterval = retryInterval;\n        this.#log = this.#log.extend(url);\n    }\n    connect(peerId, peerMetadata) {\n        if (!this.socket || !this.peerId) {\n            // first time connecting\n            this.#log(\"connecting\");\n            this.peerId = peerId;\n            this.peerMetadata = peerMetadata ?? {};\n        }\n        else {\n            this.#log(\"reconnecting\");\n            assert(peerId === this.peerId);\n            // Remove the old event listeners before creating a new connection.\n            this.socket.removeEventListener(\"open\", this.onOpen);\n            this.socket.removeEventListener(\"close\", this.onClose);\n            this.socket.removeEventListener(\"message\", this.onMessage);\n            this.socket.removeEventListener(\"error\", this.onError);\n        }\n        // Wire up retries\n        if (!this.#retryIntervalId)\n            this.#retryIntervalId = setInterval(() =\u003e {\n                this.connect(peerId, peerMetadata);\n            }, this.retryInterval);\n        this.socket = new WebSocket(this.url);\n        this.socket.binaryType = \"arraybuffer\";\n        this.socket.addEventListener(\"open\", this.onOpen);\n        this.socket.addEventListener(\"close\", this.onClose);\n        this.socket.addEventListener(\"message\", this.onMessage);\n        this.socket.addEventListener(\"error\", this.onError);\n        // Mark this adapter as ready if we haven't received an ack in 1 second.\n        // We might hear back from the other end at some point but we shouldn't\n        // hold up marking things as unavailable for any longer\n        setTimeout(() =\u003e this.#forceReady(), 1000);\n        this.join();\n    }\n    onOpen = () =\u003e {\n        this.#log(\"open\");\n        clearInterval(this.#retryIntervalId);\n        this.#retryIntervalId = undefined;\n        this.join();\n    };\n    // When a socket closes, or disconnects, remove it from the array.\n    onClose = () =\u003e {\n        this.#log(\"close\");\n        if (this.remotePeerId)\n            this.emit(\"peer-disconnected\", { peerId: this.remotePeerId });\n        if (this.retryInterval \u003e 0 \u0026\u0026 !this.#retryIntervalId)\n            // try to reconnect\n            setTimeout(() =\u003e {\n                assert(this.peerId);\n                return this.connect(this.peerId, this.peerMetadata);\n            }, this.retryInterval);\n    };\n    onMessage = (event) =\u003e {\n        this.receiveMessage(event.data);\n    };\n    /** The websocket error handler signature is different on node and the browser.  */\n    onError = (event // node\n    ) =\u003e {\n        if (\"error\" in event) {\n            // (node)\n            if (event.error.code !== \"ECONNREFUSED\") {\n                /* c8 ignore next */\n                throw event.error;\n            }\n        }\n        else {\n            // (browser) We get no information about errors. https://stackoverflow.com/a/31003057/239663\n            // There will be an error logged in the console (`WebSocket connection to 'wss://foo.com/'\n            // failed`), but by design the error is unavailable to scripts. We'll just assume this is a\n            // failed connection.\n        }\n        this.#log(\"Connection failed, retrying...\");\n    };\n    join() {\n        assert(this.peerId);\n        assert(this.socket);\n        if (this.socket.readyState === WebSocket.OPEN) {\n            this.send(joinMessage(this.peerId, this.peerMetadata));\n        }\n        else {\n            // We'll try again in the `onOpen` handler\n        }\n    }\n    disconnect() {\n        assert(this.peerId);\n        assert(this.socket);\n        const socket = this.socket;\n        if (socket) {\n            socket.removeEventListener(\"open\", this.onOpen);\n            socket.removeEventListener(\"close\", this.onClose);\n            socket.removeEventListener(\"message\", this.onMessage);\n            socket.removeEventListener(\"error\", this.onError);\n            socket.close();\n        }\n        clearInterval(this.#retryIntervalId);\n        if (this.remotePeerId)\n            this.emit(\"peer-disconnected\", { peerId: this.remotePeerId });\n        this.socket = undefined;\n    }\n    send(message) {\n        if (\"data\" in message \u0026\u0026 message.data?.byteLength === 0)\n            throw new Error(\"Tried to send a zero-length message\");\n        assert(this.peerId);\n        if (!this.socket) {\n            this.#log(\"Tried to send on a disconnected socket.\");\n            return;\n        }\n        if (this.socket.readyState !== WebSocket.OPEN)\n            throw new Error(`Websocket not ready (${this.socket.readyState})`);\n        const encoded = cbor.encode(message);\n        this.socket.send(toArrayBuffer(encoded));\n    }\n    peerCandidate(remotePeerId, peerMetadata) {\n        assert(this.socket);\n        this.#forceReady();\n        this.remotePeerId = remotePeerId;\n        this.emit(\"peer-candidate\", {\n            peerId: remotePeerId,\n            peerMetadata,\n        });\n    }\n    receiveMessage(messageBytes) {\n        const message = cbor.decode(new Uint8Array(messageBytes));\n        assert(this.socket);\n        if (messageBytes.byteLength === 0)\n            throw new Error(\"received a zero-length message\");\n        if (isPeerMessage(message)) {\n            const { peerMetadata } = message;\n            this.#log(`peer: ${message.senderId}`);\n            this.peerCandidate(message.senderId, peerMetadata);\n        }\n        else if (isErrorMessage(message)) {\n            this.#log(`error: ${message.message}`);\n        }\n        else {\n            this.emit(\"message\", message);\n        }\n    }\n}\nfunction joinMessage(senderId, peerMetadata) {\n    return {\n        type: \"join\",\n        senderId,\n        peerMetadata,\n        supportedProtocolVersions: [ProtocolV1],\n    };\n}\n","// TYPE GUARDS\nexport const isJoinMessage = (message) =\u003e message.type === \"join\";\nexport const isPeerMessage = (message) =\u003e message.type === \"peer\";\nexport const isErrorMessage = (message) =\u003e message.type === \"error\";\n","export const ProtocolV1 = \"1\";\n","/* c8 ignore start */\nexport function assert(value, message = \"Assertion failed\") {\n    if (value === false || value === null || value === undefined) {\n        const error = new Error(trimLines(message));\n        error.stack = removeLine(error.stack, \"assert.ts\");\n        throw error;\n    }\n}\nconst trimLines = (s) =\u003e s\n    .split(\"\\n\")\n    .map(s =\u003e s.trim())\n    .join(\"\\n\");\nconst removeLine = (s = \"\", targetText) =\u003e s\n    .split(\"\\n\")\n    .filter(line =\u003e !line.includes(targetText))\n    .join(\"\\n\");\n/* c8 ignore end */\n","/**\n * This incantation deals with websocket sending the whole underlying buffer even if we just have a\n * uint8array view on it\n */\nexport const toArrayBuffer = (bytes) =\u003e {\n    const { buffer, byteOffset, byteLength } = bytes;\n    return buffer.slice(byteOffset, byteOffset + byteLength);\n};\n","import WebSocket from \"isomorphic-ws\";\nimport debug from \"debug\";\nconst log = debug(\"WebsocketServer\");\nimport { cbor as cborHelpers, NetworkAdapter, } from \"@automerge/automerge-repo/slim\";\nimport { isJoinMessage, } from \"./messages.js\";\nimport { ProtocolV1 } from \"./protocolVersion.js\";\nimport { assert } from \"./assert.js\";\nimport { toArrayBuffer } from \"./toArrayBuffer.js\";\nconst { encode, decode } = cborHelpers;\nexport class NodeWSServerAdapter extends NetworkAdapter {\n    server;\n    keepAliveInterval;\n    sockets = {};\n    #ready = false;\n    #readyResolver;\n    #readyPromise = new Promise(resolve =\u003e {\n        this.#readyResolver = resolve;\n    });\n    isReady() {\n        return this.#ready;\n    }\n    whenReady() {\n        return this.#readyPromise;\n    }\n    #forceReady() {\n        if (!this.#ready) {\n            this.#ready = true;\n            this.#readyResolver?.();\n        }\n    }\n    constructor(server, keepAliveInterval = 5000) {\n        super();\n        this.server = server;\n        this.keepAliveInterval = keepAliveInterval;\n    }\n    connect(peerId, peerMetadata) {\n        this.peerId = peerId;\n        this.peerMetadata = peerMetadata;\n        this.server.on(\"close\", () =\u003e {\n            clearInterval(keepAliveId);\n            this.disconnect();\n        });\n        this.server.on(\"connection\", (socket) =\u003e {\n            // When a socket closes, or disconnects, remove it from our list\n            socket.on(\"close\", () =\u003e {\n                this.#removeSocket(socket);\n            });\n            socket.on(\"message\", message =\u003e this.receiveMessage(message, socket));\n            // Start out \"alive\", and every time we get a pong, reset that state.\n            socket.isAlive = true;\n            socket.on(\"pong\", () =\u003e (socket.isAlive = true));\n            this.#forceReady();\n        });\n        const keepAliveId = setInterval(() =\u003e {\n            // Terminate connections to lost clients\n            const clients = this.server.clients;\n            clients.forEach(socket =\u003e {\n                if (socket.isAlive) {\n                    // Mark all clients as potentially dead until we hear from them\n                    socket.isAlive = false;\n                    socket.ping();\n                }\n                else {\n                    this.#terminate(socket);\n                }\n            });\n        }, this.keepAliveInterval);\n    }\n    disconnect() {\n        const clients = this.server.clients;\n        clients.forEach(socket =\u003e {\n            this.#terminate(socket);\n            this.#removeSocket(socket);\n        });\n    }\n    send(message) {\n        assert(\"targetId\" in message \u0026\u0026 message.targetId !== undefined);\n        if (\"data\" in message \u0026\u0026 message.data?.byteLength === 0)\n            throw new Error(\"Tried to send a zero-length message\");\n        const senderId = this.peerId;\n        assert(senderId, \"No peerId set for the websocket server network adapter.\");\n        const socket = this.sockets[message.targetId];\n        if (!socket) {\n            log(`Tried to send to disconnected peer: ${message.targetId}`);\n            return;\n        }\n        const encoded = encode(message);\n        const arrayBuf = toArrayBuffer(encoded);\n        socket.send(arrayBuf);\n    }\n    receiveMessage(messageBytes, socket) {\n        const message = decode(messageBytes);\n        const { type, senderId } = message;\n        const myPeerId = this.peerId;\n        assert(myPeerId);\n        const documentId = \"documentId\" in message ? \"@\" + message.documentId : \"\";\n        const { byteLength } = messageBytes;\n        log(`[${senderId}-\u003e${myPeerId}${documentId}] ${type} | ${byteLength} bytes`);\n        if (isJoinMessage(message)) {\n            const { peerMetadata, supportedProtocolVersions } = message;\n            const existingSocket = this.sockets[senderId];\n            if (existingSocket) {\n                if (existingSocket.readyState === WebSocket.OPEN) {\n                    existingSocket.close();\n                }\n                this.emit(\"peer-disconnected\", { peerId: senderId });\n            }\n            // Let the repo know that we have a new connection.\n            this.emit(\"peer-candidate\", { peerId: senderId, peerMetadata });\n            this.sockets[senderId] = socket;\n            const selectedProtocolVersion = selectProtocol(supportedProtocolVersions);\n            if (selectedProtocolVersion === null) {\n                this.send({\n                    type: \"error\",\n                    senderId: this.peerId,\n                    message: \"unsupported protocol version\",\n                    targetId: senderId,\n                });\n                this.sockets[senderId].close();\n                delete this.sockets[senderId];\n            }\n            else {\n                this.send({\n                    type: \"peer\",\n                    senderId: this.peerId,\n                    peerMetadata: this.peerMetadata,\n                    selectedProtocolVersion: ProtocolV1,\n                    targetId: senderId,\n                });\n            }\n        }\n        else {\n            this.emit(\"message\", message);\n        }\n    }\n    #terminate(socket) {\n        this.#removeSocket(socket);\n        socket.terminate();\n    }\n    #removeSocket(socket) {\n        const peerId = this.#peerIdBySocket(socket);\n        if (!peerId)\n            return;\n        this.emit(\"peer-disconnected\", { peerId });\n        delete this.sockets[peerId];\n    }\n    #peerIdBySocket = (socket) =\u003e {\n        const isThisSocket = (peerId) =\u003e this.sockets[peerId] === socket;\n        const result = Object.keys(this.sockets).find(isThisSocket);\n        return result ?? null;\n    };\n}\nconst selectProtocol = (versions) =\u003e {\n    if (versions === undefined)\n        return ProtocolV1;\n    if (versions.includes(ProtocolV1))\n        return ProtocolV1;\n    return null;\n};\n"],"version":3}

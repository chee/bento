/* esm.sh - esbuild bundle(@automerge/automerge-repo-storage-indexeddb@2.0.0-alpha.11) es2022 production */
var d=class{database;store;dbPromise;constructor(e="automerge",n="documents"){this.database=e,this.store=n,this.dbPromise=this.createDatabasePromise()}createDatabasePromise(){return new Promise((e,n)=>{let t=indexedDB.open(this.database,1);t.onerror=()=>{n(t.error)},t.onupgradeneeded=o=>{o.target.result.createObjectStore(this.store)},t.onsuccess=o=>{let s=o.target.result;e(s)}})}async load(e){let t=(await this.dbPromise).transaction(this.store),s=t.objectStore(this.store).get(e);return new Promise((r,i)=>{t.onerror=()=>{i(s.error)},s.onsuccess=a=>{let c=a.target.result;c&&typeof c=="object"&&"binary"in c?r(c.binary):r(void 0)}})}async save(e,n){let o=(await this.dbPromise).transaction(this.store,"readwrite");return o.objectStore(this.store).put({key:e,binary:n},e),new Promise((r,i)=>{o.onerror=()=>{i(o.error)},o.oncomplete=()=>{r()}})}async remove(e){let t=(await this.dbPromise).transaction(this.store,"readwrite");return t.objectStore(this.store).delete(e),new Promise((s,r)=>{t.onerror=()=>{r(t.error)},t.oncomplete=()=>{s()}})}async loadRange(e){let n=await this.dbPromise,t=e,o=[...e,"\uFFFF"],s=IDBKeyRange.bound(t,o),r=n.transaction(this.store),a=r.objectStore(this.store).openCursor(s),c=[];return new Promise((u,h)=>{r.onerror=()=>{h(a.error)},a.onsuccess=m=>{let b=m.target.result;b?(c.push({data:b.value.binary,key:b.key}),b.continue()):u(c)}})}async removeRange(e){let n=await this.dbPromise,t=e,o=[...e,"\uFFFF"],s=IDBKeyRange.bound(t,o),r=n.transaction(this.store,"readwrite");return r.objectStore(this.store).delete(s),new Promise((a,c)=>{r.onerror=()=>{c(r.error)},r.oncomplete=()=>{a()}})}};export{d as IndexedDBStorageAdapter};
//# sourceMappingURL=automerge-repo-storage-indexeddb.mjs.map